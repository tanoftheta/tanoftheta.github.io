import {
  require_events
} from "./chunk-T63CUCTV.js";
import {
  init_src10 as init_src6,
  init_src12 as init_src7,
  init_src17 as init_src8,
  init_src2 as init_src,
  init_src3 as init_src2,
  init_src5 as init_src3,
  init_src6 as init_src4,
  init_src9 as init_src5,
  src_exports,
  src_exports2,
  src_exports3,
  src_exports4,
  src_exports5,
  src_exports6,
  src_exports7,
  src_exports8
} from "./chunk-AWUYTKNZ.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-WXXH56N5.js";

// node_modules/function-plot/dist/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/function-plot/dist/polyfills.js"() {
    if (typeof window !== "undefined")
      (function(doc, proto) {
        try {
          doc.querySelector(":scope body");
        } catch (err) {
          ["querySelector", "querySelectorAll"].forEach(function(method) {
            const native = proto[method];
            proto[method] = function(selectors) {
              if (/(^|,)\s*:scope/.test(selectors)) {
                const id = this.id;
                this.id = "ID_" + Date.now();
                selectors = selectors.replace(/((^|,)\s*):scope/g, "$1#" + this.id);
                const result = doc[method](selectors);
                this.id = id;
                return result;
              } else {
                return native.call(this, selectors);
              }
            };
          });
        }
      })(window.document, Element.prototype);
  }
});

// node_modules/function-plot/dist/helpers/annotations.js
var require_annotations = __commonJS({
  "node_modules/function-plot/dist/helpers/annotations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_shape_1 = (init_src(), __toCommonJS(src_exports));
    var d3_selection_1 = (init_src7(), __toCommonJS(src_exports7));
    function annotations(options) {
      const xScale = options.owner.meta.xScale;
      const yScale = options.owner.meta.yScale;
      const line = (0, d3_shape_1.line)().x(function(d) {
        return d[0];
      }).y(function(d) {
        return d[1];
      });
      return function(parentSelection) {
        parentSelection.each(function() {
          const current = (0, d3_selection_1.select)(this);
          const selection = current.selectAll("g.annotations").data(function(d) {
            return d.annotations || [];
          });
          const enter = selection.enter().append("g").attr("class", "annotations");
          const yRange = yScale.range();
          const xRange = xScale.range();
          const path = selection.merge(enter).selectAll("path").data(function(d) {
            if ("x" in d) {
              return [[[0, yRange[0]], [0, yRange[1]]]];
            } else {
              return [[[xRange[0], 0], [xRange[1], 0]]];
            }
          });
          path.enter().append("path").attr("stroke", "#eee").attr("d", line);
          path.exit().remove();
          const text = selection.merge(enter).selectAll("text").data(function(d) {
            return [
              {
                text: d.text || "",
                hasX: "x" in d
              }
            ];
          });
          text.enter().append("text").attr("y", function(d) {
            return d.hasX ? 3 : 0;
          }).attr("x", function(d) {
            return d.hasX ? 0 : 3;
          }).attr("dy", function(d) {
            return d.hasX ? 5 : -5;
          }).attr("text-anchor", function(d) {
            return d.hasX ? "end" : "";
          }).attr("transform", function(d) {
            return d.hasX ? "rotate(-90)" : "";
          }).text(function(d) {
            return d.text;
          });
          text.exit().remove();
          selection.merge(enter).attr("transform", function(d) {
            if ("x" in d) {
              return "translate(" + xScale(d.x) + ", 0)";
            } else {
              return "translate(0, " + yScale(d.y) + ")";
            }
          });
          selection.exit().remove();
        });
      };
    }
    exports.default = annotations;
  }
});

// node_modules/function-plot/dist/globals.js
var require_globals = __commonJS({
  "node_modules/function-plot/dist/globals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.registerGraphType = void 0;
    var d3_color_1 = (init_src3(), __toCommonJS(src_exports3));
    var Globals = {
      COLORS: [
        "steelblue",
        "red",
        "#05b378",
        "orange",
        "#4040e8",
        "yellow",
        "brown",
        "magenta",
        "cyan"
      ].map(function(v) {
        return (0, d3_color_1.hsl)(v);
      }),
      DEFAULT_WIDTH: 550,
      DEFAULT_HEIGHT: 350,
      DEFAULT_ITERATIONS: null,
      TIP_X_EPS: 1,
      MAX_ITERATIONS: 0,
      graphTypes: {}
    };
    Globals.MAX_ITERATIONS = Globals.DEFAULT_WIDTH * 10;
    function registerGraphType(graphType, graphTypeBulder) {
      if (Object.hasOwn(Globals.graphTypes, graphType)) {
        throw new Error(`registerGraphType: graphType ${graphType} is already registered.`);
      }
      Globals.graphTypes[graphType] = graphTypeBulder;
    }
    exports.registerGraphType = registerGraphType;
    exports.default = Globals;
  }
});

// node_modules/function-plot/dist/utils.js
var require_utils = __commonJS({
  "node_modules/function-plot/dist/utils.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals_1 = __importDefault(require_globals());
    var utils = {
      linspace: function(lo, hi, n) {
        const step = (hi - lo) / (n - 1);
        return Array.from({ length: n }, (_, i) => lo + step * i);
      },
      logspace: function(lo, hi, n) {
        return this.linspace(lo, hi, n).map((x) => Math.pow(10, x));
      },
      isValidNumber: function(v) {
        return typeof v === "number" && !isNaN(v);
      },
      space: function(axis, range, n) {
        const lo = range[0];
        const hi = range[1];
        if (axis.type === "log") {
          return this.logspace(Math.log10(lo), Math.log10(hi), n);
        }
        return this.linspace(lo, hi, n);
      },
      getterSetter: function(config, option) {
        const me = this;
        this[option] = function(value) {
          if (!arguments.length) {
            return config[option];
          }
          config[option] = value;
          return me;
        };
      },
      sgn: function(v) {
        if (v < 0) {
          return -1;
        }
        if (v > 0) {
          return 1;
        }
        return 0;
      },
      clamp: function(v, vMin, vMax) {
        if (v < vMin)
          return vMin;
        if (v > vMax)
          return vMax;
        return v;
      },
      color: function(data, index) {
        const indexModLenColor = index % globals_1.default.COLORS.length;
        return data.color || globals_1.default.COLORS[indexModLenColor].hex();
      },
      /**
       * Infinity is a value that is close to Infinity but not Infinity, it can fit in a JS number.
       */
      infinity: function() {
        return 9007199254740991;
      }
    };
    exports.default = utils;
  }
});

// node_modules/mr-parser/lib/token-type.js
var require_token_type = __commonJS({
  "node_modules/mr-parser/lib/token-type.js"(exports, module) {
    module.exports = {
      EOF: 0,
      DELIMITER: 1,
      NUMBER: 2,
      STRING: 3,
      SYMBOL: 4
    };
  }
});

// node_modules/mr-parser/lib/Lexer.js
var require_Lexer = __commonJS({
  "node_modules/mr-parser/lib/Lexer.js"(exports, module) {
    var tokenType = require_token_type();
    var ESCAPES = {
      "n": "\n",
      "f": "\f",
      "r": "\r",
      "t": "	",
      "v": "\v",
      "'": "'",
      '"': '"'
    };
    var DELIMITERS = {
      ",": true,
      "(": true,
      ")": true,
      "[": true,
      "]": true,
      ";": true,
      // unary
      "~": true,
      // factorial
      "!": true,
      // arithmetic operators
      "+": true,
      "-": true,
      "*": true,
      "/": true,
      "%": true,
      "^": true,
      "**": true,
      // python power like
      // misc operators
      "|": true,
      // bitwise or
      "&": true,
      // bitwise and
      "^|": true,
      // bitwise xor
      "=": true,
      ":": true,
      "?": true,
      "||": true,
      // logical or
      "&&": true,
      // logical and
      "xor": true,
      // logical xor
      // relational
      "==": true,
      "!=": true,
      "===": true,
      "!==": true,
      "<": true,
      ">": true,
      ">=": true,
      "<=": true,
      // shifts
      ">>>": true,
      "<<": true,
      ">>": true
    };
    function isDigit(c) {
      return c >= "0" && c <= "9";
    }
    function isIdentifier(c) {
      return c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "$" || c === "_";
    }
    function isWhitespace(c) {
      return c === " " || c === "\r" || c === "	" || c === "\n" || c === "\v" || c === "Â ";
    }
    function isDelimiter(str) {
      return DELIMITERS[str];
    }
    function isQuote(c) {
      return c === "'" || c === '"';
    }
    function Lexer() {
    }
    Lexer.prototype.throwError = function(message, index) {
      index = typeof index === "undefined" ? this.index : index;
      var error = new Error(message + " at index " + index);
      error.index = index;
      error.description = message;
      throw error;
    };
    Lexer.prototype.lex = function(text) {
      this.text = text;
      this.index = 0;
      this.tokens = [];
      while (this.index < this.text.length) {
        while (isWhitespace(this.peek())) {
          this.consume();
        }
        var c = this.peek();
        var c2 = c + this.peek(1);
        var c3 = c2 + this.peek(2);
        if (isDelimiter(c3)) {
          this.tokens.push({
            type: tokenType.DELIMITER,
            value: c3
          });
          this.consume();
          this.consume();
          this.consume();
        } else if (isDelimiter(c2)) {
          this.tokens.push({
            type: tokenType.DELIMITER,
            value: c2
          });
          this.consume();
          this.consume();
        } else if (isDelimiter(c)) {
          this.tokens.push({
            type: tokenType.DELIMITER,
            value: c
          });
          this.consume();
        } else if (isDigit(c) || c === "." && isDigit(this.peek(1))) {
          this.tokens.push({
            type: tokenType.NUMBER,
            value: this.readNumber()
          });
        } else if (isQuote(c)) {
          this.tokens.push({
            type: tokenType.STRING,
            value: this.readString()
          });
        } else if (isIdentifier(c)) {
          this.tokens.push({
            type: tokenType.SYMBOL,
            value: this.readIdentifier()
          });
        } else {
          this.throwError("unexpected character " + c);
        }
      }
      this.tokens.push({ type: tokenType.EOF });
      return this.tokens;
    };
    Lexer.prototype.peek = function(nth) {
      nth = nth || 0;
      if (this.index + nth >= this.text.length) {
        return;
      }
      return this.text.charAt(this.index + nth);
    };
    Lexer.prototype.consume = function() {
      var current = this.peek();
      this.index += 1;
      return current;
    };
    Lexer.prototype.readNumber = function() {
      var number = "";
      if (this.peek() === ".") {
        number += this.consume();
        if (!isDigit(this.peek())) {
          this.throwError("number expected");
        }
      } else {
        while (isDigit(this.peek())) {
          number += this.consume();
        }
        if (this.peek() === ".") {
          number += this.consume();
        }
      }
      while (isDigit(this.peek())) {
        number += this.consume();
      }
      if (this.peek() === "e" || this.peek() === "E") {
        number += this.consume();
        if (!(isDigit(this.peek()) || this.peek() === "+" || this.peek() === "-")) {
          this.throwError();
        }
        if (this.peek() === "+" || this.peek() === "-") {
          number += this.consume();
        }
        if (!isDigit(this.peek())) {
          this.throwError("number expected");
        }
        while (isDigit(this.peek())) {
          number += this.consume();
        }
      }
      return number;
    };
    Lexer.prototype.readIdentifier = function() {
      var text = "";
      while (isIdentifier(this.peek()) || isDigit(this.peek())) {
        text += this.consume();
      }
      return text;
    };
    Lexer.prototype.readString = function() {
      var quote = this.consume();
      var string = "";
      var escape;
      while (true) {
        var c = this.consume();
        if (!c) {
          this.throwError("string is not closed");
        }
        if (escape) {
          if (c === "u") {
            var hex = this.text.substring(this.index + 1, this.index + 5);
            if (!hex.match(/[\da-f]{4}/i)) {
              this.throwError("invalid unicode escape");
            }
            this.index += 4;
            string += String.fromCharCode(parseInt(hex, 16));
          } else {
            var replacement = ESCAPES[c];
            if (replacement) {
              string += replacement;
            } else {
              string += c;
            }
          }
          escape = false;
        } else if (c === quote) {
          break;
        } else if (c === "\\") {
          escape = true;
        } else {
          string += c;
        }
      }
      return string;
    };
    module.exports = Lexer;
  }
});

// node_modules/mr-parser/lib/node/Node.js
var require_Node = __commonJS({
  "node_modules/mr-parser/lib/node/Node.js"(exports, module) {
    function Node() {
    }
    Node.prototype.type = "Node";
    module.exports = Node;
  }
});

// node_modules/mr-parser/lib/node/ConstantNode.js
var require_ConstantNode = __commonJS({
  "node_modules/mr-parser/lib/node/ConstantNode.js"(exports, module) {
    var Node = require_Node();
    var SUPPORTED_TYPES = {
      number: true,
      string: true,
      "boolean": true,
      "undefined": true,
      "null": true
    };
    function ConstantNode(value, type) {
      if (!SUPPORTED_TYPES[type]) {
        throw Error("unsupported type '" + type + "'");
      }
      this.value = value;
      this.valueType = type;
    }
    ConstantNode.prototype = Object.create(Node.prototype);
    ConstantNode.prototype.type = "ConstantNode";
    module.exports = ConstantNode;
  }
});

// node_modules/mr-parser/lib/node/OperatorNode.js
var require_OperatorNode = __commonJS({
  "node_modules/mr-parser/lib/node/OperatorNode.js"(exports, module) {
    var Node = require_Node();
    function OperatorNode(op, args) {
      this.op = op;
      this.args = args || [];
    }
    OperatorNode.prototype = Object.create(Node.prototype);
    OperatorNode.prototype.type = "OperatorNode";
    module.exports = OperatorNode;
  }
});

// node_modules/mr-parser/lib/node/UnaryNode.js
var require_UnaryNode = __commonJS({
  "node_modules/mr-parser/lib/node/UnaryNode.js"(exports, module) {
    var Node = require_Node();
    function UnaryNode(op, argument) {
      this.op = op;
      this.argument = argument;
    }
    UnaryNode.prototype = Object.create(Node.prototype);
    UnaryNode.prototype.type = "UnaryNode";
    module.exports = UnaryNode;
  }
});

// node_modules/mr-parser/lib/node/SymbolNode.js
var require_SymbolNode = __commonJS({
  "node_modules/mr-parser/lib/node/SymbolNode.js"(exports, module) {
    var Node = require_Node();
    function SymbolNode(name) {
      this.name = name;
    }
    SymbolNode.prototype = Object.create(Node.prototype);
    SymbolNode.prototype.type = "SymbolNode";
    module.exports = SymbolNode;
  }
});

// node_modules/mr-parser/lib/node/FunctionNode.js
var require_FunctionNode = __commonJS({
  "node_modules/mr-parser/lib/node/FunctionNode.js"(exports, module) {
    var Node = require_Node();
    function FunctionNode(name, args) {
      this.name = name;
      this.args = args;
    }
    FunctionNode.prototype = Object.create(Node.prototype);
    FunctionNode.prototype.type = "FunctionNode";
    module.exports = FunctionNode;
  }
});

// node_modules/mr-parser/lib/node/ArrayNode.js
var require_ArrayNode = __commonJS({
  "node_modules/mr-parser/lib/node/ArrayNode.js"(exports, module) {
    var Node = require_Node();
    function ArrayNode(nodes) {
      this.nodes = nodes;
    }
    ArrayNode.prototype = Object.create(Node.prototype);
    ArrayNode.prototype.type = "ArrayNode";
    module.exports = ArrayNode;
  }
});

// node_modules/mr-parser/lib/node/ConditionalNode.js
var require_ConditionalNode = __commonJS({
  "node_modules/mr-parser/lib/node/ConditionalNode.js"(exports, module) {
    var Node = require_Node();
    function ConditionalNode(predicate, truthy, falsy) {
      this.condition = predicate;
      this.trueExpr = truthy;
      this.falseExpr = falsy;
    }
    ConditionalNode.prototype = Object.create(Node.prototype);
    ConditionalNode.prototype.type = "ConditionalNode";
    module.exports = ConditionalNode;
  }
});

// node_modules/mr-parser/lib/node/AssignmentNode.js
var require_AssignmentNode = __commonJS({
  "node_modules/mr-parser/lib/node/AssignmentNode.js"(exports, module) {
    var Node = require_Node();
    function AssignmentNode(name, expr) {
      this.name = name;
      this.expr = expr;
    }
    AssignmentNode.prototype = Object.create(Node.prototype);
    AssignmentNode.prototype.type = "AssignmentNode";
    module.exports = AssignmentNode;
  }
});

// node_modules/mr-parser/lib/node/BlockNode.js
var require_BlockNode = __commonJS({
  "node_modules/mr-parser/lib/node/BlockNode.js"(exports, module) {
    var Node = require_Node();
    function BlockNode(blocks) {
      this.blocks = blocks;
    }
    BlockNode.prototype = Object.create(Node.prototype);
    BlockNode.prototype.type = "BlockNode";
    module.exports = BlockNode;
  }
});

// node_modules/mr-parser/lib/Parser.js
var require_Parser = __commonJS({
  "node_modules/mr-parser/lib/Parser.js"(exports, module) {
    var tokenType = require_token_type();
    var Lexer = require_Lexer();
    var ConstantNode = require_ConstantNode();
    var OperatorNode = require_OperatorNode();
    var UnaryNode = require_UnaryNode();
    var SymbolNode = require_SymbolNode();
    var FunctionNode = require_FunctionNode();
    var ArrayNode = require_ArrayNode();
    var ConditionalNode = require_ConditionalNode();
    var AssignmentNode = require_AssignmentNode();
    var BlockNode = require_BlockNode();
    function Parser() {
      this.lexer = new Lexer();
      this.tokens = null;
    }
    Parser.prototype.current = function() {
      return this.tokens[0];
    };
    Parser.prototype.next = function() {
      return this.tokens[1];
    };
    Parser.prototype.peek = function() {
      if (this.tokens.length) {
        var first = this.tokens[0];
        for (var i = 0; i < arguments.length; i += 1) {
          if (first.value === arguments[i]) {
            return true;
          }
        }
      }
    };
    Parser.prototype.consume = function(e) {
      return this.tokens.shift();
    };
    Parser.prototype.expect = function(e) {
      if (!this.peek(e)) {
        throw Error("expected " + e);
      }
      return this.consume();
    };
    Parser.prototype.isEOF = function() {
      return this.current().type === tokenType.EOF;
    };
    Parser.prototype.parse = function(text) {
      this.tokens = this.lexer.lex(text);
      return this.program();
    };
    Parser.prototype.program = function() {
      var blocks = [];
      while (!this.isEOF()) {
        blocks.push(this.assignment());
        if (this.peek(";")) {
          this.consume();
        }
      }
      this.end();
      return new BlockNode(blocks);
    };
    Parser.prototype.assignment = function() {
      var left = this.ternary();
      if (left instanceof SymbolNode && this.peek("=")) {
        this.consume();
        return new AssignmentNode(left.name, this.assignment());
      }
      return left;
    };
    Parser.prototype.ternary = function() {
      var predicate = this.logicalOR();
      if (this.peek("?")) {
        this.consume();
        var truthy = this.ternary();
        this.expect(":");
        var falsy = this.ternary();
        return new ConditionalNode(predicate, truthy, falsy);
      }
      return predicate;
    };
    Parser.prototype.logicalOR = function() {
      var left = this.logicalXOR();
      if (this.peek("||")) {
        var op = this.consume();
        var right = this.logicalOR();
        return new OperatorNode(op.value, [left, right]);
      }
      return left;
    };
    Parser.prototype.logicalXOR = function() {
      var left = this.logicalAND();
      if (this.current().value === "xor") {
        var op = this.consume();
        var right = this.logicalXOR();
        return new OperatorNode(op.value, [left, right]);
      }
      return left;
    };
    Parser.prototype.logicalAND = function() {
      var left = this.bitwiseOR();
      if (this.peek("&&")) {
        var op = this.consume();
        var right = this.logicalAND();
        return new OperatorNode(op.value, [left, right]);
      }
      return left;
    };
    Parser.prototype.bitwiseOR = function() {
      var left = this.bitwiseXOR();
      if (this.peek("|")) {
        var op = this.consume();
        var right = this.bitwiseOR();
        return new OperatorNode(op.value, [left, right]);
      }
      return left;
    };
    Parser.prototype.bitwiseXOR = function() {
      var left = this.bitwiseAND();
      if (this.peek("^|")) {
        var op = this.consume();
        var right = this.bitwiseXOR();
        return new OperatorNode(op.value, [left, right]);
      }
      return left;
    };
    Parser.prototype.bitwiseAND = function() {
      var left = this.relational();
      if (this.peek("&")) {
        var op = this.consume();
        var right = this.bitwiseAND();
        return new OperatorNode(op.value, [left, right]);
      }
      return left;
    };
    Parser.prototype.relational = function() {
      var left = this.shift();
      if (this.peek("==", "===", "!=", "!==", ">=", "<=", ">", "<")) {
        var op = this.consume();
        var right = this.shift();
        return new OperatorNode(op.value, [left, right]);
      }
      return left;
    };
    Parser.prototype.shift = function() {
      var left = this.additive();
      if (this.peek(">>", "<<", ">>>")) {
        var op = this.consume();
        var right = this.shift();
        return new OperatorNode(op.value, [left, right]);
      }
      return left;
    };
    Parser.prototype.additive = function() {
      var left = this.multiplicative();
      while (this.peek("+", "-")) {
        var op = this.consume();
        left = new OperatorNode(op.value, [left, this.multiplicative()]);
      }
      return left;
    };
    Parser.prototype.multiplicative = function() {
      var op, right;
      var left = this.unary();
      while (this.peek("*", "/", "%")) {
        op = this.consume();
        left = new OperatorNode(op.value, [left, this.unary()]);
      }
      if (this.current().type === tokenType.SYMBOL || this.peek("(") || !(left.type instanceof ConstantNode) && this.current().type === tokenType.NUMBER) {
        right = this.multiplicative();
        return new OperatorNode("*", [left, right]);
      }
      return left;
    };
    Parser.prototype.unary = function() {
      if (this.peek("-", "+", "~")) {
        var op = this.consume();
        var right = this.unary();
        return new UnaryNode(op.value, right);
      }
      return this.pow();
    };
    Parser.prototype.pow = function() {
      var left = this.factorial();
      if (this.peek("^", "**")) {
        var op = this.consume();
        var right = this.unary();
        return new OperatorNode(op.value, [left, right]);
      }
      return left;
    };
    Parser.prototype.factorial = function() {
      var left = this.symbol();
      if (this.peek("!")) {
        var op = this.consume();
        return new OperatorNode(op.value, [left]);
      }
      return left;
    };
    Parser.prototype.symbol = function() {
      var current = this.current();
      if (current.type === tokenType.SYMBOL) {
        var symbol = this.consume();
        var node = this.functionCall(symbol);
        return node;
      }
      return this.string();
    };
    Parser.prototype.functionCall = function(symbolToken) {
      var name = symbolToken.value;
      if (this.peek("(")) {
        this.consume();
        var params = [];
        while (!this.peek(")") && !this.isEOF()) {
          params.push(this.assignment());
          if (this.peek(",")) {
            this.consume();
          }
        }
        this.expect(")");
        return new FunctionNode(name, params);
      }
      return new SymbolNode(name);
    };
    Parser.prototype.string = function() {
      if (this.current().type === tokenType.STRING) {
        return new ConstantNode(this.consume().value, "string");
      }
      return this.array();
    };
    Parser.prototype.array = function() {
      if (this.peek("[")) {
        this.consume();
        var params = [];
        while (!this.peek("]") && !this.isEOF()) {
          params.push(this.assignment());
          if (this.peek(",")) {
            this.consume();
          }
        }
        this.expect("]");
        return new ArrayNode(params);
      }
      return this.number();
    };
    Parser.prototype.number = function() {
      var token = this.current();
      if (token.type === tokenType.NUMBER) {
        return new ConstantNode(this.consume().value, "number");
      }
      return this.parentheses();
    };
    Parser.prototype.parentheses = function() {
      var token = this.current();
      if (token.value === "(") {
        this.consume();
        var left = this.assignment();
        this.expect(")");
        return left;
      }
      return this.end();
    };
    Parser.prototype.end = function() {
      var token = this.current();
      if (token.type !== tokenType.EOF) {
        throw Error("unexpected end of expression");
      }
    };
    module.exports = Parser;
  }
});

// node_modules/mr-parser/lib/node/index.js
var require_node = __commonJS({
  "node_modules/mr-parser/lib/node/index.js"(exports, module) {
    module.exports = {
      ArrayNode: require_ArrayNode(),
      AssignmentNode: require_AssignmentNode(),
      BlockNode: require_BlockNode(),
      ConditionalNode: require_ConditionalNode(),
      ConstantNode: require_ConstantNode(),
      FunctionNode: require_FunctionNode(),
      Node: require_Node(),
      OperatorNode: require_OperatorNode(),
      SymbolNode: require_SymbolNode(),
      UnaryNode: require_UnaryNode()
    };
  }
});

// node_modules/mr-parser/index.js
var require_mr_parser = __commonJS({
  "node_modules/mr-parser/index.js"(exports, module) {
    "use strict";
    module.exports.Lexer = require_Lexer();
    module.exports.Parser = require_Parser();
    module.exports.nodeTypes = require_node();
  }
});

// node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/extend/index.js"(exports, module) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray = function isArray2(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject = function isPlainObject2(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    };
    module.exports = function extend() {
      var options, name, src, copy, copyIsArray, clone2;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy = getProperty(options, name);
            if (target !== copy) {
              if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone2 = src && isArray(src) ? src : [];
                } else {
                  clone2 = src && isPlainObject(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend(deep, clone2, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// node_modules/math-codegen/lib/node/ArrayNode.js
var require_ArrayNode2 = __commonJS({
  "node_modules/math-codegen/lib/node/ArrayNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      var self = this;
      var arr = [];
      this.rawify(this.options.rawArrayExpressionElements, function() {
        arr = node.nodes.map(function(el) {
          return self.next(el);
        });
      });
      var arrString = "[" + arr.join(",") + "]";
      if (this.options.raw) {
        return arrString;
      }
      return this.options.factory + "(" + arrString + ")";
    };
  }
});

// node_modules/math-codegen/lib/node/AssignmentNode.js
var require_AssignmentNode2 = __commonJS({
  "node_modules/math-codegen/lib/node/AssignmentNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      return 'scope["' + node.name + '"] = ' + this.next(node.expr);
    };
  }
});

// node_modules/math-codegen/lib/node/ConditionalNode.js
var require_ConditionalNode2 = __commonJS({
  "node_modules/math-codegen/lib/node/ConditionalNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      var condition = "!!(" + this.next(node.condition) + ")";
      var trueExpr = this.next(node.trueExpr);
      var falseExpr = this.next(node.falseExpr);
      return "(" + condition + " ? (" + trueExpr + ") : (" + falseExpr + ") )";
    };
  }
});

// node_modules/math-codegen/lib/node/ConstantNode.js
var require_ConstantNode2 = __commonJS({
  "node_modules/math-codegen/lib/node/ConstantNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      if (this.options.raw) {
        return node.value;
      }
      return this.options.factory + "(" + node.value + ")";
    };
  }
});

// node_modules/math-codegen/lib/node/FunctionNode.js
var require_FunctionNode2 = __commonJS({
  "node_modules/math-codegen/lib/node/FunctionNode.js"(exports, module) {
    "use strict";
    var SymbolNode = require_mr_parser().nodeTypes.SymbolNode;
    var functionProxy = function(node) {
      return "$$mathCodegen.functionProxy(" + this.next(new SymbolNode(node.name)) + ', "' + node.name + '")';
    };
    module.exports = function(node) {
      var self = this;
      var method = functionProxy.call(this, node);
      var args = [];
      this.rawify(this.options.rawCallExpressionElements, function() {
        args = node.args.map(function(arg) {
          return self.next(arg);
        });
      });
      return method + "(" + args.join(", ") + ")";
    };
    module.exports.functionProxy = functionProxy;
  }
});

// node_modules/math-codegen/lib/misc/Operators.js
var require_Operators = __commonJS({
  "node_modules/math-codegen/lib/misc/Operators.js"(exports, module) {
    "use strict";
    module.exports = {
      // arithmetic
      "+": "add",
      "-": "sub",
      "*": "mul",
      "/": "div",
      "^": "pow",
      "%": "mod",
      "!": "factorial",
      // misc operators
      "|": "bitwiseOR",
      // bitwise or
      "^|": "bitwiseXOR",
      // bitwise xor
      "&": "bitwiseAND",
      // bitwise and
      "||": "logicalOR",
      // logical or
      "xor": "logicalXOR",
      // logical xor
      "&&": "logicalAND",
      // logical and
      // comparison
      "<": "lessThan",
      ">": "greaterThan",
      "<=": "lessEqualThan",
      ">=": "greaterEqualThan",
      "===": "strictlyEqual",
      "==": "equal",
      "!==": "strictlyNotEqual",
      "!=": "notEqual",
      // shift
      ">>": "shiftRight",
      "<<": "shiftLeft",
      ">>>": "unsignedRightShift"
    };
  }
});

// node_modules/math-codegen/lib/node/OperatorNode.js
var require_OperatorNode2 = __commonJS({
  "node_modules/math-codegen/lib/node/OperatorNode.js"(exports, module) {
    "use strict";
    var Operators = require_Operators();
    module.exports = function(node) {
      if (this.options.raw) {
        return ["(" + this.next(node.args[0]), node.op, this.next(node.args[1]) + ")"].join(" ");
      }
      var namedOperator = Operators[node.op];
      if (!namedOperator) {
        throw TypeError("unidentified operator");
      }
      return this.FunctionNode({
        name: namedOperator,
        args: node.args
      });
    };
  }
});

// node_modules/math-codegen/lib/node/SymbolNode.js
var require_SymbolNode2 = __commonJS({
  "node_modules/math-codegen/lib/node/SymbolNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      var id = node.name;
      return '$$mathCodegen.getProperty("' + id + '", scope, ns)';
    };
  }
});

// node_modules/math-codegen/lib/misc/UnaryOperators.js
var require_UnaryOperators = __commonJS({
  "node_modules/math-codegen/lib/misc/UnaryOperators.js"(exports, module) {
    "use strict";
    module.exports = {
      "+": "positive",
      "-": "negative",
      "~": "oneComplement"
    };
  }
});

// node_modules/math-codegen/lib/node/UnaryNode.js
var require_UnaryNode2 = __commonJS({
  "node_modules/math-codegen/lib/node/UnaryNode.js"(exports, module) {
    "use strict";
    var UnaryOperators = require_UnaryOperators();
    module.exports = function(node) {
      if (this.options.raw) {
        return node.op + this.next(node.argument);
      }
      if (!(node.op in UnaryOperators)) {
        throw new SyntaxError(node.op + " not implemented");
      }
      var namedOperator = UnaryOperators[node.op];
      return this.FunctionNode({
        name: namedOperator,
        args: [node.argument]
      });
    };
  }
});

// node_modules/math-codegen/lib/Interpreter.js
var require_Interpreter = __commonJS({
  "node_modules/math-codegen/lib/Interpreter.js"(exports, module) {
    "use strict";
    var extend = require_extend();
    var types = {
      ArrayNode: require_ArrayNode2(),
      AssignmentNode: require_AssignmentNode2(),
      ConditionalNode: require_ConditionalNode2(),
      ConstantNode: require_ConstantNode2(),
      FunctionNode: require_FunctionNode2(),
      OperatorNode: require_OperatorNode2(),
      SymbolNode: require_SymbolNode2(),
      UnaryNode: require_UnaryNode2()
    };
    var Interpreter = function(owner, options) {
      this.owner = owner;
      this.options = extend({
        factory: "ns.factory",
        raw: false,
        rawArrayExpressionElements: true,
        rawCallExpressionElements: false
      }, options);
    };
    extend(Interpreter.prototype, types);
    Interpreter.prototype.next = function(node) {
      if (!(node.type in this)) {
        throw new TypeError("the node type " + node.type + " is not implemented");
      }
      return this[node.type](node);
    };
    Interpreter.prototype.rawify = function(test, fn) {
      var oldRaw = this.options.raw;
      if (test) {
        this.options.raw = true;
      }
      fn();
      if (test) {
        this.options.raw = oldRaw;
      }
    };
    module.exports = Interpreter;
  }
});

// node_modules/math-codegen/lib/CodeGenerator.js
var require_CodeGenerator = __commonJS({
  "node_modules/math-codegen/lib/CodeGenerator.js"(exports, module) {
    "use strict";
    var Parser = require_mr_parser().Parser;
    var Interpreter = require_Interpreter();
    var extend = require_extend();
    function CodeGenerator(options, defs) {
      this.statements = [];
      this.defs = defs || {};
      this.interpreter = new Interpreter(this, options);
    }
    CodeGenerator.prototype.setDefs = function(defs) {
      this.defs = extend(this.defs, defs);
      return this;
    };
    CodeGenerator.prototype.compile = function(namespace) {
      if (!namespace || !(typeof namespace === "object" || typeof namespace === "function")) {
        throw TypeError("namespace must be an object");
      }
      if (typeof namespace.factory !== "function") {
        throw TypeError("namespace.factory must be a function");
      }
      this.defs.ns = namespace;
      this.defs.$$mathCodegen = {
        getProperty: function(symbol, scope, ns) {
          if (symbol in scope) {
            return scope[symbol];
          }
          if (symbol in ns) {
            return ns[symbol];
          }
          throw SyntaxError('symbol "' + symbol + '" is undefined');
        },
        functionProxy: function(fn, name) {
          if (typeof fn !== "function") {
            throw SyntaxError('symbol "' + name + '" must be a function');
          }
          return fn;
        }
      };
      this.defs.$$processScope = this.defs.$$processScope || function() {
      };
      var defsCode = Object.keys(this.defs).map(function(name) {
        return "var " + name + ' = defs["' + name + '"]';
      });
      if (!this.statements.length) {
        throw Error("there are no statements saved in this generator, make sure you parse an expression before compiling it");
      }
      this.statements[this.statements.length - 1] = "return " + this.statements[this.statements.length - 1];
      var code = this.statements.join(";");
      var factoryCode = defsCode.join("\n") + "\n" + [
        "return {",
        "  eval: function (scope) {",
        "    scope = scope || {}",
        "    $$processScope(scope)",
        "    " + code,
        "  },",
        "  code: '" + code + "'",
        "}"
      ].join("\n");
      var factory = new Function("defs", factoryCode);
      return factory(this.defs);
    };
    CodeGenerator.prototype.parse = function(code) {
      var self = this;
      var program = new Parser().parse(code);
      this.statements = program.blocks.map(function(statement) {
        return self.interpreter.next(statement);
      });
      return this;
    };
    module.exports = CodeGenerator;
  }
});

// node_modules/math-codegen/index.js
var require_math_codegen = __commonJS({
  "node_modules/math-codegen/index.js"(exports, module) {
    "use strict";
    module.exports = require_CodeGenerator();
  }
});

// node_modules/built-in-math-eval/lib/adapter.js
var require_adapter = __commonJS({
  "node_modules/built-in-math-eval/lib/adapter.js"(exports, module) {
    "use strict";
    module.exports = function() {
      var math = Object.create(Math);
      math.factory = function(a) {
        if (typeof a !== "number") {
          throw new TypeError("built-in math factory only accepts numbers");
        }
        return Number(a);
      };
      math.add = function(a, b) {
        return a + b;
      };
      math.sub = function(a, b) {
        return a - b;
      };
      math.mul = function(a, b) {
        return a * b;
      };
      math.div = function(a, b) {
        return a / b;
      };
      math.mod = function(a, b) {
        return a % b;
      };
      math.factorial = function(a) {
        var res = 1;
        for (var i = 2; i <= a; i += 1) {
          res *= i;
        }
        return res;
      };
      math.nthRoot = function(a, root) {
        var inv = root < 0;
        if (inv) {
          root = -root;
        }
        if (root === 0) {
          throw new Error("Root must be non-zero");
        }
        if (a < 0 && Math.abs(root) % 2 !== 1) {
          throw new Error("Root must be odd when a is negative.");
        }
        if (a === 0) {
          return 0;
        }
        if (!isFinite(a)) {
          return inv ? 0 : a;
        }
        var x = Math.pow(Math.abs(a), 1 / root);
        x = a < 0 ? -x : x;
        return inv ? 1 / x : x;
      };
      math.logicalOR = function(a, b) {
        return a || b;
      };
      math.logicalXOR = function(a, b) {
        return a != b;
      };
      math.logicalAND = function(a, b) {
        return a && b;
      };
      math.bitwiseOR = function(a, b) {
        return a | b;
      };
      math.bitwiseXOR = function(a, b) {
        return a ^ b;
      };
      math.bitwiseAND = function(a, b) {
        return a & b;
      };
      math.lessThan = function(a, b) {
        return a < b;
      };
      math.lessEqualThan = function(a, b) {
        return a <= b;
      };
      math.greaterThan = function(a, b) {
        return a > b;
      };
      math.greaterEqualThan = function(a, b) {
        return a >= b;
      };
      math.equal = function(a, b) {
        return a == b;
      };
      math.strictlyEqual = function(a, b) {
        return a === b;
      };
      math.notEqual = function(a, b) {
        return a != b;
      };
      math.strictlyNotEqual = function(a, b) {
        return a !== b;
      };
      math.shiftRight = function(a, b) {
        return a >> b;
      };
      math.shiftLeft = function(a, b) {
        return a << b;
      };
      math.unsignedRightShift = function(a, b) {
        return a >>> b;
      };
      math.negative = function(a) {
        return -a;
      };
      math.positive = function(a) {
        return a;
      };
      return math;
    };
  }
});

// node_modules/built-in-math-eval/lib/eval.js
var require_eval = __commonJS({
  "node_modules/built-in-math-eval/lib/eval.js"(exports, module) {
    "use strict";
    var CodeGenerator = require_math_codegen();
    var math = require_adapter()();
    function processScope(scope) {
      Object.keys(scope).forEach(function(k) {
        var value = scope[k];
        scope[k] = math.factory(value);
      });
    }
    module.exports = function(expression) {
      return new CodeGenerator().setDefs({
        $$processScope: processScope
      }).parse(expression).compile(math);
    };
    module.exports.math = math;
  }
});

// node_modules/built-in-math-eval/index.js
var require_built_in_math_eval = __commonJS({
  "node_modules/built-in-math-eval/index.js"(exports, module) {
    "use strict";
    module.exports = require_eval();
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/ArrayNode.js
var require_ArrayNode3 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/ArrayNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      var self = this;
      var arr = [];
      this.rawify(this.options.rawArrayExpressionElements, function() {
        arr = node.nodes.map(function(el) {
          return self.next(el);
        });
      });
      var arrString = "[" + arr.join(",") + "]";
      if (this.options.raw) {
        return arrString;
      }
      return this.options.factory + "(" + arrString + ")";
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/AssignmentNode.js
var require_AssignmentNode3 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/AssignmentNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      return 'scope["' + node.name + '"] = ' + this.next(node.expr);
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/ConditionalNode.js
var require_ConditionalNode3 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/ConditionalNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      var condition = "!!(" + this.next(node.condition) + ")";
      var trueExpr = this.next(node.trueExpr);
      var falseExpr = this.next(node.falseExpr);
      return "(" + condition + " ? (" + trueExpr + ") : (" + falseExpr + ") )";
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/ConstantNode.js
var require_ConstantNode3 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/ConstantNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      if (this.options.raw) {
        return node.value;
      }
      return this.options.factory + "(" + node.value + ")";
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/FunctionNode.js
var require_FunctionNode3 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/FunctionNode.js"(exports, module) {
    "use strict";
    var SymbolNode = require_mr_parser().nodeTypes.SymbolNode;
    var functionProxy = function(node) {
      return "$$mathCodegen.functionProxy(" + this.next(new SymbolNode(node.name)) + ', "' + node.name + '")';
    };
    module.exports = function(node) {
      var self = this;
      var method = functionProxy.call(this, node);
      var args = [];
      this.rawify(this.options.rawCallExpressionElements, function() {
        args = node.args.map(function(arg) {
          return self.next(arg);
        });
      });
      return method + "(" + args.join(", ") + ")";
    };
    module.exports.functionProxy = functionProxy;
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/misc/Operators.js
var require_Operators2 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/misc/Operators.js"(exports, module) {
    "use strict";
    module.exports = {
      // arithmetic
      "+": "add",
      "-": "sub",
      "*": "mul",
      "/": "div",
      "^": "pow",
      "%": "mod",
      "!": "factorial",
      // misc operators
      "|": "bitwiseOR",
      // bitwise or
      "^|": "bitwiseXOR",
      // bitwise xor
      "&": "bitwiseAND",
      // bitwise and
      "||": "logicalOR",
      // logical or
      "xor": "logicalXOR",
      // logical xor
      "&&": "logicalAND",
      // logical and
      // comparison
      "<": "lessThan",
      ">": "greaterThan",
      "<=": "lessEqualThan",
      ">=": "greaterEqualThan",
      "===": "strictlyEqual",
      "==": "equal",
      "!==": "strictlyNotEqual",
      "!=": "notEqual",
      // shift
      ">>": "shiftRight",
      "<<": "shiftLeft",
      ">>>": "unsignedRightShift"
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/OperatorNode.js
var require_OperatorNode3 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/OperatorNode.js"(exports, module) {
    "use strict";
    var Operators = require_Operators2();
    module.exports = function(node) {
      if (this.options.raw) {
        return ["(" + this.next(node.args[0]), node.op, this.next(node.args[1]) + ")"].join(" ");
      }
      var namedOperator = Operators[node.op];
      if (!namedOperator) {
        throw TypeError("unidentified operator");
      }
      return this.FunctionNode({
        name: namedOperator,
        args: node.args
      });
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/SymbolNode.js
var require_SymbolNode3 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/SymbolNode.js"(exports, module) {
    "use strict";
    module.exports = function(node) {
      var id = node.name;
      return '$$mathCodegen.getProperty("' + id + '", scope, ns)';
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/misc/UnaryOperators.js
var require_UnaryOperators2 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/misc/UnaryOperators.js"(exports, module) {
    "use strict";
    module.exports = {
      "+": "positive",
      "-": "negative",
      "~": "oneComplement"
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/UnaryNode.js
var require_UnaryNode3 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/node/UnaryNode.js"(exports, module) {
    "use strict";
    var UnaryOperators = require_UnaryOperators2();
    module.exports = function(node) {
      if (this.options.raw) {
        return node.op + this.next(node.argument);
      }
      if (!(node.op in UnaryOperators)) {
        throw new SyntaxError(node.op + " not implemented");
      }
      var namedOperator = UnaryOperators[node.op];
      return this.FunctionNode({
        name: namedOperator,
        args: [node.argument]
      });
    };
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/Interpreter.js
var require_Interpreter2 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/Interpreter.js"(exports, module) {
    "use strict";
    var extend = require_extend();
    var types = {
      ArrayNode: require_ArrayNode3(),
      AssignmentNode: require_AssignmentNode3(),
      ConditionalNode: require_ConditionalNode3(),
      ConstantNode: require_ConstantNode3(),
      FunctionNode: require_FunctionNode3(),
      OperatorNode: require_OperatorNode3(),
      SymbolNode: require_SymbolNode3(),
      UnaryNode: require_UnaryNode3()
    };
    var Interpreter = function(owner, options) {
      this.owner = owner;
      this.options = extend({
        factory: "ns.factory",
        raw: false,
        rawArrayExpressionElements: true,
        rawCallExpressionElements: false,
        applyFactoryToScope: false
      }, options);
    };
    extend(Interpreter.prototype, types);
    Interpreter.prototype.next = function(node) {
      if (!(node.type in this)) {
        throw new TypeError("the node type " + node.type + " is not implemented");
      }
      return this[node.type](node);
    };
    Interpreter.prototype.rawify = function(test, fn) {
      var oldRaw = this.options.raw;
      if (test) {
        this.options.raw = true;
      }
      fn();
      if (test) {
        this.options.raw = oldRaw;
      }
    };
    module.exports = Interpreter;
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/CodeGenerator.js
var require_CodeGenerator2 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/lib/CodeGenerator.js"(exports, module) {
    "use strict";
    var Parser = require_mr_parser().Parser;
    var Interpreter = require_Interpreter2();
    var extend = require_extend();
    function CodeGenerator(options, defs) {
      this.statements = [];
      this.defs = defs || {};
      this.interpreter = new Interpreter(this, options);
    }
    CodeGenerator.prototype.setDefs = function(defs) {
      this.defs = extend(this.defs, defs);
      return this;
    };
    CodeGenerator.prototype.compile = function(namespace) {
      var self = this;
      if (!namespace || !(typeof namespace === "object" || typeof namespace === "function")) {
        throw TypeError("namespace must be an object");
      }
      if (typeof namespace.factory !== "function") {
        throw TypeError("namespace.factory must be a function");
      }
      this.defs.ns = namespace;
      this.defs.$$mathCodegen = {
        getProperty: function(symbol, scope, ns) {
          function applyFactoryIfNeeded(value) {
            if (self.interpreter.options.applyFactoryToScope && typeof value !== "function") {
              return ns.factory(value);
            }
            return value;
          }
          if (symbol in scope) {
            return applyFactoryIfNeeded(scope[symbol]);
          }
          if (symbol in ns) {
            return applyFactoryIfNeeded(ns[symbol]);
          }
          throw SyntaxError('symbol "' + symbol + '" is undefined');
        },
        functionProxy: function(fn, name) {
          if (typeof fn !== "function") {
            throw SyntaxError('symbol "' + name + '" must be a function');
          }
          return fn;
        }
      };
      this.defs.$$processScope = this.defs.$$processScope || function() {
      };
      var defsCode = Object.keys(this.defs).map(function(name) {
        return "var " + name + ' = defs["' + name + '"]';
      });
      if (!this.statements.length) {
        throw Error("there are no statements saved in this generator, make sure you parse an expression before compiling it");
      }
      this.statements[this.statements.length - 1] = "return " + this.statements[this.statements.length - 1];
      var code = this.statements.join(";");
      var factoryCode = defsCode.join("\n") + "\n" + [
        "return {",
        "  eval: function (scope) {",
        "    scope = scope || {}",
        "    $$processScope(scope)",
        "    " + code,
        "  },",
        "  code: '" + code + "'",
        "}"
      ].join("\n");
      var factory = new Function("defs", factoryCode);
      return factory(this.defs);
    };
    CodeGenerator.prototype.parse = function(code) {
      var self = this;
      var program = new Parser().parse(code);
      this.statements = program.blocks.map(function(statement) {
        return self.interpreter.next(statement);
      });
      return this;
    };
    module.exports = CodeGenerator;
  }
});

// node_modules/interval-arithmetic-eval/node_modules/math-codegen/index.js
var require_math_codegen2 = __commonJS({
  "node_modules/interval-arithmetic-eval/node_modules/math-codegen/index.js"(exports, module) {
    "use strict";
    module.exports = require_CodeGenerator2();
  }
});

// node_modules/interval-arithmetic/lib-esm/operations/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasInterval: () => hasInterval,
  hasValue: () => hasValue,
  intervalsOverlap: () => intervalsOverlap,
  isEmpty: () => isEmpty,
  isInterval: () => isInterval,
  isSingleton: () => isSingleton,
  isWhole: () => isWhole,
  zeroIn: () => zeroIn
});
function isInterval(x) {
  return typeof x === "object" && typeof x.lo === "number" && typeof x.hi === "number";
}
function isEmpty(i) {
  return i.lo > i.hi;
}
function isWhole(i) {
  return i.lo === -Infinity && i.hi === Infinity;
}
function isSingleton(i) {
  return i.lo === i.hi;
}
function zeroIn(i) {
  return hasValue(i, 0);
}
function hasValue(i, value) {
  if (isEmpty(i)) {
    return false;
  }
  return i.lo <= value && value <= i.hi;
}
function hasInterval(x, y) {
  if (isEmpty(x)) {
    return true;
  }
  return !isEmpty(y) && y.lo <= x.lo && x.hi <= y.hi;
}
function intervalsOverlap(x, y) {
  if (isEmpty(x) || isEmpty(y)) {
    return false;
  }
  return x.lo <= y.lo && y.lo <= x.hi || y.lo <= x.lo && x.lo <= y.hi;
}
var init_utils = __esm({
  "node_modules/interval-arithmetic/lib-esm/operations/utils.js"() {
  }
});

// node_modules/double-bits/double.js
var require_double = __commonJS({
  "node_modules/double-bits/double.js"(exports, module) {
    var hasTypedArrays = false;
    if (typeof Float64Array !== "undefined") {
      DOUBLE_VIEW = new Float64Array(1), UINT_VIEW = new Uint32Array(DOUBLE_VIEW.buffer);
      DOUBLE_VIEW[0] = 1;
      hasTypedArrays = true;
      if (UINT_VIEW[1] === 1072693248) {
        let toDoubleLE2 = function(lo, hi) {
          UINT_VIEW[0] = lo;
          UINT_VIEW[1] = hi;
          return DOUBLE_VIEW[0];
        }, lowUintLE2 = function(n) {
          DOUBLE_VIEW[0] = n;
          return UINT_VIEW[0];
        }, highUintLE2 = function(n) {
          DOUBLE_VIEW[0] = n;
          return UINT_VIEW[1];
        };
        toDoubleLE = toDoubleLE2, lowUintLE = lowUintLE2, highUintLE = highUintLE2;
        module.exports = function doubleBitsLE(n) {
          DOUBLE_VIEW[0] = n;
          return [UINT_VIEW[0], UINT_VIEW[1]];
        };
        module.exports.pack = toDoubleLE2;
        module.exports.lo = lowUintLE2;
        module.exports.hi = highUintLE2;
      } else if (UINT_VIEW[0] === 1072693248) {
        let toDoubleBE2 = function(lo, hi) {
          UINT_VIEW[1] = lo;
          UINT_VIEW[0] = hi;
          return DOUBLE_VIEW[0];
        }, lowUintBE2 = function(n) {
          DOUBLE_VIEW[0] = n;
          return UINT_VIEW[1];
        }, highUintBE2 = function(n) {
          DOUBLE_VIEW[0] = n;
          return UINT_VIEW[0];
        };
        toDoubleBE = toDoubleBE2, lowUintBE = lowUintBE2, highUintBE = highUintBE2;
        module.exports = function doubleBitsBE(n) {
          DOUBLE_VIEW[0] = n;
          return [UINT_VIEW[1], UINT_VIEW[0]];
        };
        module.exports.pack = toDoubleBE2;
        module.exports.lo = lowUintBE2;
        module.exports.hi = highUintBE2;
      } else {
        hasTypedArrays = false;
      }
    }
    var DOUBLE_VIEW;
    var UINT_VIEW;
    var toDoubleLE;
    var lowUintLE;
    var highUintLE;
    var toDoubleBE;
    var lowUintBE;
    var highUintBE;
    if (!hasTypedArrays) {
      let toDouble2 = function(lo, hi) {
        buffer.writeUInt32LE(lo, 0, true);
        buffer.writeUInt32LE(hi, 4, true);
        return buffer.readDoubleLE(0, true);
      }, lowUint2 = function(n) {
        buffer.writeDoubleLE(n, 0, true);
        return buffer.readUInt32LE(0, true);
      }, highUint2 = function(n) {
        buffer.writeDoubleLE(n, 0, true);
        return buffer.readUInt32LE(4, true);
      };
      toDouble = toDouble2, lowUint = lowUint2, highUint = highUint2;
      buffer = new Buffer(8);
      module.exports = function doubleBits(n) {
        buffer.writeDoubleLE(n, 0, true);
        return [buffer.readUInt32LE(0, true), buffer.readUInt32LE(4, true)];
      };
      module.exports.pack = toDouble2;
      module.exports.lo = lowUint2;
      module.exports.hi = highUint2;
    }
    var buffer;
    var toDouble;
    var lowUint;
    var highUint;
    module.exports.sign = function(n) {
      return module.exports.hi(n) >>> 31;
    };
    module.exports.exponent = function(n) {
      var b = module.exports.hi(n);
      return (b << 1 >>> 21) - 1023;
    };
    module.exports.fraction = function(n) {
      var lo = module.exports.lo(n);
      var hi = module.exports.hi(n);
      var b = hi & (1 << 20) - 1;
      if (hi & 2146435072) {
        b += 1 << 20;
      }
      return [lo, b];
    };
    module.exports.denormalized = function(n) {
      var hi = module.exports.hi(n);
      return !(hi & 2146435072);
    };
  }
});

// node_modules/nextafter/nextafter.js
var require_nextafter = __commonJS({
  "node_modules/nextafter/nextafter.js"(exports, module) {
    "use strict";
    var doubleBits = require_double();
    var SMALLEST_DENORM = Math.pow(2, -1074);
    var UINT_MAX = -1 >>> 0;
    module.exports = nextafter2;
    function nextafter2(x, y) {
      if (isNaN(x) || isNaN(y)) {
        return NaN;
      }
      if (x === y) {
        return x;
      }
      if (x === 0) {
        if (y < 0) {
          return -SMALLEST_DENORM;
        } else {
          return SMALLEST_DENORM;
        }
      }
      var hi = doubleBits.hi(x);
      var lo = doubleBits.lo(x);
      if (y > x === x > 0) {
        if (lo === UINT_MAX) {
          hi += 1;
          lo = 0;
        } else {
          lo += 1;
        }
      } else {
        if (lo === 0) {
          lo = UINT_MAX;
          hi -= 1;
        } else {
          lo -= 1;
        }
      }
      return doubleBits.pack(lo, hi);
    }
  }
});

// node_modules/interval-arithmetic/lib-esm/round.js
function identity(v) {
  return v;
}
function prev(v) {
  if (v === Infinity) {
    return v;
  }
  return (0, import_nextafter.default)(v, -Infinity);
}
function next(v) {
  if (v === -Infinity) {
    return v;
  }
  return (0, import_nextafter.default)(v, Infinity);
}
function toInteger(x) {
  return x < 0 ? Math.ceil(x) : Math.floor(x);
}
var import_nextafter, cache, round, round_default;
var init_round = __esm({
  "node_modules/interval-arithmetic/lib-esm/round.js"() {
    import_nextafter = __toESM(require_nextafter());
    cache = {
      prev,
      next
    };
    round = {
      /**
       * Computes the previous IEEE floating point representation of `v`
       * @example
       * Interval.round.safePrev(1)          // 0.9999999999999999
       * Interval.round.safePrev(3)          // 2.9999999999999996
       * Interval.round.safePrev(Infinity)   // Infinity
       * @param {number} v
       * @return {number}
       * @function
       */
      safePrev: prev,
      /**
       * Computes the next IEEE floating point representation of `v`
       * @example
       * Interval.round.safeNext(1)          // 1.0000000000000002
       * Interval.round.safeNext(3)          // 3.0000000000000004
       * Interval.round.safeNext(-Infinity)  // -Infinity
       * @param {number} v
       * @return {number}
       * @function
       */
      safeNext: next,
      prev(x) {
        return cache.prev(x);
      },
      next(x) {
        return cache.next(x);
      },
      // prettier-ignore
      addLo(x, y) {
        return round.prev(x + y);
      },
      // prettier-ignore
      addHi(x, y) {
        return round.next(x + y);
      },
      // prettier-ignore
      subLo(x, y) {
        return round.prev(x - y);
      },
      // prettier-ignore
      subHi(x, y) {
        return round.next(x - y);
      },
      // prettier-ignore
      mulLo(x, y) {
        return round.prev(x * y);
      },
      // prettier-ignore
      mulHi(x, y) {
        return round.next(x * y);
      },
      // prettier-ignore
      divLo(x, y) {
        return round.prev(x / y);
      },
      // prettier-ignore
      divHi(x, y) {
        return round.next(x / y);
      },
      // prettier-ignore
      intLo(x) {
        return toInteger(round.prev(x));
      },
      // prettier-ignore
      intHi(x) {
        return toInteger(round.next(x));
      },
      // prettier-ignore
      logLo(x) {
        return round.prev(Math.log(x));
      },
      // prettier-ignore
      logHi(x) {
        return round.next(Math.log(x));
      },
      // prettier-ignore
      expLo(x) {
        return round.prev(Math.exp(x));
      },
      // prettier-ignore
      expHi(x) {
        return round.next(Math.exp(x));
      },
      // prettier-ignore
      sinLo(x) {
        return round.prev(Math.sin(x));
      },
      // prettier-ignore
      sinHi(x) {
        return round.next(Math.sin(x));
      },
      // prettier-ignore
      cosLo(x) {
        return round.prev(Math.cos(x));
      },
      // prettier-ignore
      cosHi(x) {
        return round.next(Math.cos(x));
      },
      // prettier-ignore
      tanLo(x) {
        return round.prev(Math.tan(x));
      },
      // prettier-ignore
      tanHi(x) {
        return round.next(Math.tan(x));
      },
      // prettier-ignore
      asinLo(x) {
        return round.prev(Math.asin(x));
      },
      // prettier-ignore
      asinHi(x) {
        return round.next(Math.asin(x));
      },
      // prettier-ignore
      acosLo(x) {
        return round.prev(Math.acos(x));
      },
      // prettier-ignore
      acosHi(x) {
        return round.next(Math.acos(x));
      },
      // prettier-ignore
      atanLo(x) {
        return round.prev(Math.atan(x));
      },
      // prettier-ignore
      atanHi(x) {
        return round.next(Math.atan(x));
      },
      // polyfill required for hyperbolic functions
      // prettier-ignore
      sinhLo(x) {
        return round.prev(Math.sinh(x));
      },
      // prettier-ignore
      sinhHi(x) {
        return round.next(Math.sinh(x));
      },
      // prettier-ignore
      coshLo(x) {
        return round.prev(Math.cosh(x));
      },
      // prettier-ignore
      coshHi(x) {
        return round.next(Math.cosh(x));
      },
      // prettier-ignore
      tanhLo(x) {
        return round.prev(Math.tanh(x));
      },
      // prettier-ignore
      tanhHi(x) {
        return round.next(Math.tanh(x));
      },
      /**
       * @ignore
       * ln(power) exponentiation of x
       * @param {number} x
       * @param {number} power
       * @returns {number}
       */
      powLo(x, power) {
        if (power % 1 !== 0) {
          return round.prev(Math.pow(x, power));
        }
        let y = (power & 1) === 1 ? x : 1;
        power >>= 1;
        while (power > 0) {
          x = round.mulLo(x, x);
          if ((power & 1) === 1) {
            y = round.mulLo(x, y);
          }
          power >>= 1;
        }
        return y;
      },
      /**
       * @ignore
       * ln(power) exponentiation of x
       * @param {number} x
       * @param {number} power
       * @returns {number}
       */
      powHi(x, power) {
        if (power % 1 !== 0) {
          return round.next(Math.pow(x, power));
        }
        let y = (power & 1) === 1 ? x : 1;
        power >>= 1;
        while (power > 0) {
          x = round.mulHi(x, x);
          if ((power & 1) === 1) {
            y = round.mulHi(x, y);
          }
          power >>= 1;
        }
        return y;
      },
      // prettier-ignore
      sqrtLo(x) {
        return round.prev(Math.sqrt(x));
      },
      // prettier-ignore
      sqrtHi(x) {
        return round.next(Math.sqrt(x));
      },
      /**
       * Most operations on intervals will cary the rounding error so that the
       * resulting interval correctly represents all the possible values, this feature
       * can be disabled by calling this method allowing a little boost in the
       * performance while operating on intervals
       *
       * @see module:interval-arithmetic/round-math.enable
       * @example
       * var x = Interval.add(
       *   Interval(1),
       *   Interval(1)
       * )
       * x // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}
       *
       * Interval.round.disable()
       * var y = Interval.add(
       *   Interval(1),
       *   Interval(1)
       * )
       * y // equal to {lo: 2, hi: 2}
       * @function
       */
      disable() {
        cache.next = cache.prev = identity;
      },
      /**
       * Enables IEEE previous/next floating point wrapping of values (enabled by
       * default)
       * @see module:interval-arithmetic/round-math.disable
       * @example
       * var x = Interval.add(
       *   Interval(1),
       *   Interval(1)
       * )
       * x // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}
       *
       * Interval.round.disable()
       * var y = Interval.add(
       *   Interval(1),
       *   Interval(1)
       * )
       * y // equal to {lo: 2, hi: 2}
       *
       * Interval.round.enable()
       * var z = Interval.add(
       *   Interval(1),
       *   Interval(1)
       * )
       * z // equal to {lo: 1.9999999999999998, hi: 2.0000000000000004}
       * @function
       */
      enable() {
        cache.next = next;
        cache.prev = prev;
      }
    };
    round_default = round;
  }
});

// node_modules/interval-arithmetic/lib-esm/interval.js
function bindNew(Class) {
  function _Class() {
    for (var len = arguments.length, rest = Array(len), key = 0; key < len; key++) {
      rest[key] = arguments[key];
    }
    return new (Function.prototype.bind.apply(Class, [null].concat(rest)))();
  }
  _Class.prototype = Class.prototype;
  return _Class;
}
var _Interval, Interval;
var init_interval = __esm({
  "node_modules/interval-arithmetic/lib-esm/interval.js"() {
    init_utils();
    init_round();
    _Interval = class __Interval {
      constructor(lo, hi) {
        this.lo = 0;
        this.hi = 0;
        if (!(this instanceof __Interval)) {
          console.log("calling with new");
          console.log(lo, hi);
          return new __Interval(lo, hi);
        }
        if (typeof lo !== "undefined" && typeof hi !== "undefined") {
          if (isInterval(lo)) {
            if (!isSingleton(lo)) {
              throw new TypeError("Interval: interval `lo` must be a singleton");
            }
            lo = lo.lo;
          }
          if (isInterval(hi)) {
            if (!isSingleton(hi)) {
              throw TypeError("Interval: interval `hi` must be a singleton");
            }
            hi = hi.hi;
          }
        } else if (typeof lo !== "undefined") {
          if (Array.isArray(lo)) {
            return new Interval(lo[0], lo[1]);
          }
          return new Interval(lo, lo);
        } else {
          lo = hi = 0;
        }
        this.assign(lo, hi);
      }
      /**
       * Sets `this.lo` and `this.hi` to a single value `v`
       *
       * @param {number} v
       * @return {Interval} The calling interval i.e. `this`
       */
      singleton(v) {
        return this.set(v, v);
      }
      /**
       * Sets new endpoints to this interval, the left endpoint is equal to the
       * previous IEEE floating point value of `lo` and the right endpoint
       * is equal to the next IEEE floating point
       * value of `hi`, it's assumed that `lo <= hi`
       *
       * @example
       * ```typescript
       * const x = Interval().bounded(1, 2)
       * x.lo < 1 // true, x.lo === 0.9999999999999999
       * x.hi > 2 // true, x.hi === 2.0000000000000004
       * ```
       *
       * @example
       * ```typescript
       * // the correct representation of 1/3
       * var x = Interval().bounded(1/3, 1/3)
       * x.lo < 1/3 // true
       * x.hi > 1/3 // true
       * // however the floating point representation of 1/3 is less than the real 1/3
       * // therefore the left endpoint could be 1/3 instead of the previous value of
       * var next = Interval.round.safeNext
       * var x = Interval().set(1/3, next(1/3))
       * // x now represents 1/3 correctly
       * ```
       *
       * @param {number} lo
       * @param {number} hi
       * @return {Interval} The calling interval i.e. `this`
       */
      bounded(lo, hi) {
        return this.set(round_default.prev(lo), round_default.next(hi));
      }
      /**
       * Equivalent to `Interval().bounded(v, v)`
       * @param {number} v
       * @return {Interval} The calling interval i.e. `this`
       */
      boundedSingleton(v) {
        return this.bounded(v, v);
      }
      /**
       * Sets new endpoints for this interval, this method bypasses any
       * checks on the type of arguments
       *
       * @param {Number} lo The left endpoint of the interval
       * @param {Number} hi The right endpoint of the interval
       * @return {Interval} The calling interval
       */
      set(lo, hi) {
        this.lo = lo;
        this.hi = hi;
        return this;
      }
      /**
       * Sets new endpoints for this interval checking that both arguments exist
       * and that are valid numbers, additionally if `lo > hi` the interval is set to
       * an empty interval
       *
       * @param {Number} lo The left endpoint of the interval
       * @param {Number} hi The right endpoint of the interval
       * @return {Interval} The calling interval
       */
      assign(lo, hi) {
        if (typeof lo !== "number" || typeof hi !== "number") {
          throw TypeError("Interval#assign: arguments must be numbers");
        }
        if (isNaN(lo) || isNaN(hi) || lo > hi) {
          return this.setEmpty();
        }
        return this.set(lo, hi);
      }
      /**
       * Sets the endpoints of this interval to `[â, -â]` effectively representing
       * no values
       * @return {Interval} The calling interval
       */
      setEmpty() {
        return this.set(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);
      }
      /**
       * Sets the endpoints of this interval to `[-â, â]` effectively representing all
       * the possible real values
       * @return {Interval} The calling interval
       */
      setWhole() {
        return this.set(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
      }
      /**
       * Sets the endpoints of this interval to the open interval `(lo, hi)`
       *
       * NOTE: `Interval.round.disable` has no effect on this method
       *
       * @example
       * ```typescript
       * // (2, 3)
       * Interval().open(2, 3)  // {lo: 2.0000000000000004, hi: 2.9999999999999996}
       * ```
       *
       * @param {number} lo
       * @param {number} hi
       * @return {Interval} The calling interval
       */
      open(lo, hi) {
        return this.assign(round_default.safeNext(lo), round_default.safePrev(hi));
      }
      /**
       * Sets the endpoints of this interval to the half open interval `(lo, hi]`
       *
       * NOTE: `Interval.round.disable` has no effect on this method
       *
       * @example
       * ```typescript
       * // (2, 3]
       * Interval().halfOpenLeft(2, 3)  // {lo: 2.0000000000000004, hi: 3}
       * ```
       *
       * @param {number} lo
       * @param {number} hi
       * @return {Interval} The calling interval
       */
      halfOpenLeft(lo, hi) {
        return this.assign(round_default.safeNext(lo), hi);
      }
      /**
       * Sets the endpoints of this interval to the half open interval `[lo, hi)`
       *
       * NOTE: `Interval.round.disable` has no effect on this method
       *
       * @example
       * ```typescript
       * // [2, 3)
       * Interval.halfOpenRight(2, 3)     // {lo: 2, hi: 2.9999999999999996}
       * ```
       *
       * @param {number} lo
       * @param {number} hi
       * @return {Interval} The calling interval
       */
      halfOpenRight(lo, hi) {
        return this.assign(lo, round_default.safePrev(hi));
      }
      /**
       * Array representation of this interval
       * @return {array}
       */
      toArray() {
        return [this.lo, this.hi];
      }
      /**
       * Creates an interval equal to the calling one
       * @see Interval.clone
       * @name Interval.prototype
       * @example
       * ```typescript
       * var x = Interval(2, 3)
       * x.clone()    // Interval(2, 3)
       * ```
       * @return {Interval}
       */
      clone() {
        return new Interval().set(this.lo, this.hi);
      }
    };
    Interval = bindNew(_Interval);
    Interval.factory = Interval;
  }
});

// node_modules/interval-arithmetic/lib-esm/constants.js
var piLow, piHigh, constants, constants_default;
var init_constants = __esm({
  "node_modules/interval-arithmetic/lib-esm/constants.js"() {
    init_interval();
    init_round();
    piLow = (3373259426 + 273688 / (1 << 21)) / (1 << 30);
    piHigh = (3373259426 + 273689 / (1 << 21)) / (1 << 30);
    constants = {
      /**
       * Previous IEEE floating point value of PI (equal to Math.PI)
       * 3.141592653589793
       * @memberof constants
       * @type {number}
       */
      PI_LOW: piLow,
      /**
       * Next IEEE floating point value of PI, 3.1415926535897936
       * @memberof constants
       * @type {number}
       */
      PI_HIGH: piHigh,
      PI_HALF_LOW: piLow / 2,
      PI_HALF_HIGH: piHigh / 2,
      PI_TWICE_LOW: piLow * 2,
      PI_TWICE_HIGH: piHigh * 2,
      /**
       * An interval that represents PI, NOTE: calls to Interval.PI always return
       * a new interval representing PI
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * Interval.E
       * ```
       * @name E
       * @type {Interval}
       */
      get E() {
        return new Interval(round_default.prev(Math.E), round_default.next(Math.E));
      },
      /**
       * An interval that represents Euler's constant e, NOTE: calls to Interval.E always return
       * a new interval representing PI
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * Interval(Interval.PI_LOW, Interval.PI_HIGH)
       * ```
       * @name PI
       * @type {Interval}
       */
      get PI() {
        return new Interval(piLow, piHigh);
      },
      /**
       * An interval that represents `PI / 2`, NOTE: calls to `Interval.PI_HALF` always
       * return a new interval representing `PI / 2`
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * Interval(Interval.PI_LOW / 2, Interval.PI_HIGH / 2)
       * ```
       * @name PI_HALF
       * @type {Interval}
       */
      get PI_HALF() {
        return new Interval(constants.PI_HALF_LOW, constants.PI_HALF_HIGH);
      },
      /**
       * An interval that represents `PI * 2` NOTE: calls to `Interval.PI_TWICE` always
       * return a new interval representing `PI * 2`
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * Interval(Interval.PI_LOW * 2, Interval.PI_HIGH * 2)
       * ```
       * @name PI_TWICE
       * @type {Interval}
       */
      get PI_TWICE() {
        return new Interval(constants.PI_TWICE_LOW, constants.PI_TWICE_HIGH);
      },
      /**
       * An interval that represents 0, NOTE: calls to `Interval.ZERO` always return a new interval representing 0
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * // Interval.ZERO is equivalent to
       * Interval(0)
       * ```
       * @name ZERO
       * @type {Interval}
       */
      get ZERO() {
        return new Interval(0);
      },
      /**
       * An interval that represents 1, NOTE: calls to Interval.ONE always
       * return a new interval representing 1
       * @memberof constants
       * @static
       * @example
       * // Interval.ONE is equivalent to
       * Interval(1)
       * @name ONE
       * @type {Interval}
       */
      get ONE() {
        return new Interval(1);
      },
      /**
       * An interval that represents all the real values
       * NOTE: calls to Interval.WHOLE always return a new interval representing all the real values
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * // Interval.WHOLE is equivalent to
       * Interval().setWhole()
       * ```
       * @name WHOLE
       * @type {Interval}
       */
      get WHOLE() {
        return new Interval().setWhole();
      },
      /**
       * An interval that represents no values
       * NOTE: calls to Interval.EMPTY always return a new interval representing no values
       * @memberof constants
       * @static
       * @example
       * ```typescript
       * // Interval.EMPTY is equivalent to
       * Interval().setEmpty()
       * ```
       * @name EMPTY
       * @type {Interval}
       */
      get EMPTY() {
        return new Interval().setEmpty();
      }
    };
    constants_default = constants;
  }
});

// node_modules/interval-arithmetic/lib-esm/operations/relational.js
var relational_exports = {};
__export(relational_exports, {
  almostEqual: () => almostEqual,
  assertIncludes: () => assertIncludes,
  equal: () => equal,
  geq: () => geq,
  greaterEqualThan: () => greaterEqualThan,
  greaterThan: () => greaterThan,
  gt: () => gt,
  leq: () => leq,
  lessEqualThan: () => lessEqualThan,
  lessThan: () => lessThan,
  lt: () => lt,
  notEqual: () => notEqual
});
function equal(x, y) {
  if (isEmpty(x)) {
    return isEmpty(y);
  }
  return !isEmpty(y) && x.lo === y.lo && x.hi === y.hi;
}
function assert(a, message) {
  if (!a) {
    throw new Error(message || "assertion failed");
  }
}
function assertEps(a, b) {
  if (!isFinite(a)) {
    return assert(a === b, `[Infinity] expected ${a} to be ${b}`);
  }
  assert(Math.abs(a - b) < EPS, `expected ${a} to be close to ${b}`);
}
function almostEqual(x, y) {
  x = Array.isArray(x) ? x : x.toArray();
  y = Array.isArray(y) ? y : y.toArray();
  assertEps(x[0], y[0]);
  assertEps(x[1], y[1]);
}
function assertIncludes(x, y) {
  almostEqual(x, y);
  x = Array.isArray(x) ? x : x.toArray();
  y = Array.isArray(y) ? y : y.toArray();
  assert(x[0] <= y[0], `${x[0]} should be less/equal than ${y[0]}`);
  assert(y[1] <= x[1], `${y[1]} should be less/equal than ${x[1]}`);
}
function notEqual(x, y) {
  if (isEmpty(x)) {
    return !isEmpty(y);
  }
  return isEmpty(y) || x.hi < y.lo || x.lo > y.hi;
}
function lessThan(x, y) {
  if (isEmpty(x) || isEmpty(y)) {
    return false;
  }
  return x.hi < y.lo;
}
function greaterThan(x, y) {
  if (isEmpty(x) || isEmpty(y)) {
    return false;
  }
  return x.lo > y.hi;
}
function lessEqualThan(x, y) {
  if (isEmpty(x) || isEmpty(y)) {
    return false;
  }
  return x.hi <= y.lo;
}
function greaterEqualThan(x, y) {
  if (isEmpty(x) || isEmpty(y)) {
    return false;
  }
  return x.lo >= y.hi;
}
var EPS, lt, gt, leq, geq;
var init_relational = __esm({
  "node_modules/interval-arithmetic/lib-esm/operations/relational.js"() {
    init_utils();
    EPS = 1e-7;
    lt = lessThan;
    gt = greaterThan;
    leq = lessEqualThan;
    geq = greaterEqualThan;
  }
});

// node_modules/interval-arithmetic/lib-esm/operations/division.js
function nonZero(x, y) {
  const xl = x.lo;
  const xh = x.hi;
  const yl = y.lo;
  const yh = y.hi;
  const out = new Interval();
  if (xh < 0) {
    if (yh < 0) {
      out.lo = round_default.divLo(xh, yl);
      out.hi = round_default.divHi(xl, yh);
    } else {
      out.lo = round_default.divLo(xl, yl);
      out.hi = round_default.divHi(xh, yh);
    }
  } else if (xl < 0) {
    if (yh < 0) {
      out.lo = round_default.divLo(xh, yh);
      out.hi = round_default.divHi(xl, yh);
    } else {
      out.lo = round_default.divLo(xl, yl);
      out.hi = round_default.divHi(xh, yl);
    }
  } else {
    if (yh < 0) {
      out.lo = round_default.divLo(xh, yh);
      out.hi = round_default.divHi(xl, yl);
    } else {
      out.lo = round_default.divLo(xl, yh);
      out.hi = round_default.divHi(xh, yl);
    }
  }
  return out;
}
function positive(x, v) {
  if (x.lo === 0 && x.hi === 0) {
    return x;
  }
  if (zeroIn(x)) {
    return constants_default.WHOLE;
  }
  if (x.hi < 0) {
    return new Interval(Number.NEGATIVE_INFINITY, round_default.divHi(x.hi, v));
  } else {
    return new Interval(round_default.divLo(x.lo, v), Number.POSITIVE_INFINITY);
  }
}
function negative(x, v) {
  if (x.lo === 0 && x.hi === 0) {
    return x;
  }
  if (zeroIn(x)) {
    return constants_default.WHOLE;
  }
  if (x.hi < 0) {
    return new Interval(round_default.divLo(x.hi, v), Number.POSITIVE_INFINITY);
  } else {
    return new Interval(Number.NEGATIVE_INFINITY, round_default.divHi(x.lo, v));
  }
}
function zero(x) {
  if (x.lo === 0 && x.hi === 0) {
    return x;
  }
  return constants_default.WHOLE;
}
var init_division = __esm({
  "node_modules/interval-arithmetic/lib-esm/operations/division.js"() {
    init_interval();
    init_round();
    init_utils();
    init_constants();
  }
});

// node_modules/interval-arithmetic/lib-esm/operations/arithmetic.js
var arithmetic_exports = {};
__export(arithmetic_exports, {
  add: () => add,
  div: () => div,
  divide: () => divide,
  mul: () => mul,
  multiply: () => multiply,
  negative: () => negative2,
  positive: () => positive2,
  sub: () => sub,
  subtract: () => subtract
});
function add(x, y) {
  return new Interval(round_default.addLo(x.lo, y.lo), round_default.addHi(x.hi, y.hi));
}
function subtract(x, y) {
  return new Interval(round_default.subLo(x.lo, y.hi), round_default.subHi(x.hi, y.lo));
}
function multiply(x, y) {
  if (isEmpty(x) || isEmpty(y)) {
    return constants_default.EMPTY;
  }
  const xl = x.lo;
  const xh = x.hi;
  const yl = y.lo;
  const yh = y.hi;
  const out = new Interval();
  if (xl < 0) {
    if (xh > 0) {
      if (yl < 0) {
        if (yh > 0) {
          out.lo = Math.min(round_default.mulLo(xl, yh), round_default.mulLo(xh, yl));
          out.hi = Math.max(round_default.mulHi(xl, yl), round_default.mulHi(xh, yh));
        } else {
          out.lo = round_default.mulLo(xh, yl);
          out.hi = round_default.mulHi(xl, yl);
        }
      } else {
        if (yh > 0) {
          out.lo = round_default.mulLo(xl, yh);
          out.hi = round_default.mulHi(xh, yh);
        } else {
          out.lo = 0;
          out.hi = 0;
        }
      }
    } else {
      if (yl < 0) {
        if (yh > 0) {
          out.lo = round_default.mulLo(xl, yh);
          out.hi = round_default.mulHi(xl, yl);
        } else {
          out.lo = round_default.mulLo(xh, yh);
          out.hi = round_default.mulHi(xl, yl);
        }
      } else {
        if (yh > 0) {
          out.lo = round_default.mulLo(xl, yh);
          out.hi = round_default.mulHi(xh, yl);
        } else {
          out.lo = 0;
          out.hi = 0;
        }
      }
    }
  } else {
    if (xh > 0) {
      if (yl < 0) {
        if (yh > 0) {
          out.lo = round_default.mulLo(xh, yl);
          out.hi = round_default.mulHi(xh, yh);
        } else {
          out.lo = round_default.mulLo(xh, yl);
          out.hi = round_default.mulHi(xl, yh);
        }
      } else {
        if (yh > 0) {
          out.lo = round_default.mulLo(xl, yl);
          out.hi = round_default.mulHi(xh, yh);
        } else {
          out.lo = 0;
          out.hi = 0;
        }
      }
    } else {
      out.lo = 0;
      out.hi = 0;
    }
  }
  return out;
}
function divide(x, y) {
  if (isEmpty(x) || isEmpty(y)) {
    return constants_default.EMPTY;
  }
  if (zeroIn(y)) {
    if (y.lo !== 0) {
      if (y.hi !== 0) {
        return zero(x);
      } else {
        return negative(x, y.lo);
      }
    } else {
      if (y.hi !== 0) {
        return positive(x, y.hi);
      } else {
        return constants_default.EMPTY;
      }
    }
  } else {
    return nonZero(x, y);
  }
}
function positive2(x) {
  return new Interval(x.lo, x.hi);
}
function negative2(x) {
  return new Interval(-x.hi, -x.lo);
}
var sub, mul, div;
var init_arithmetic = __esm({
  "node_modules/interval-arithmetic/lib-esm/operations/arithmetic.js"() {
    init_interval();
    init_round();
    init_constants();
    init_utils();
    init_division();
    sub = subtract;
    mul = multiply;
    div = divide;
  }
});

// node_modules/interval-arithmetic/lib-esm/operations/algebra.js
var algebra_exports = {};
__export(algebra_exports, {
  fmod: () => fmod,
  multiplicativeInverse: () => multiplicativeInverse,
  nthRoot: () => nthRoot,
  pow: () => pow,
  sqrt: () => sqrt
});
function fmod(x, y) {
  if (isEmpty(x) || isEmpty(y)) {
    return constants_default.EMPTY;
  }
  const yb = x.lo < 0 ? y.lo : y.hi;
  let n = x.lo / yb;
  if (n < 0)
    n = Math.ceil(n);
  else
    n = Math.floor(n);
  return sub(x, mul(y, new Interval(n)));
}
function multiplicativeInverse(x) {
  if (isEmpty(x)) {
    return constants_default.EMPTY;
  }
  if (zeroIn(x)) {
    if (x.lo !== 0) {
      if (x.hi !== 0) {
        return constants_default.WHOLE;
      } else {
        return new Interval(Number.NEGATIVE_INFINITY, round_default.divHi(1, x.lo));
      }
    } else {
      if (x.hi !== 0) {
        return new Interval(round_default.divLo(1, x.hi), Number.POSITIVE_INFINITY);
      } else {
        return constants_default.EMPTY;
      }
    }
  } else {
    return new Interval(round_default.divLo(1, x.hi), round_default.divHi(1, x.lo));
  }
}
function pow(x, power) {
  if (isEmpty(x)) {
    return constants_default.EMPTY;
  }
  if (typeof power === "object") {
    if (!isSingleton(power)) {
      return constants_default.EMPTY;
    }
    power = power.lo;
  }
  if (power === 0) {
    if (x.lo === 0 && x.hi === 0) {
      return constants_default.EMPTY;
    } else {
      return constants_default.ONE;
    }
  } else if (power < 0) {
    return pow(multiplicativeInverse(x), -power);
  }
  if (Number.isSafeInteger(power)) {
    if (x.hi < 0) {
      const yl = round_default.powLo(-x.hi, power);
      const yh = round_default.powHi(-x.lo, power);
      if ((power & 1) === 1) {
        return new Interval(-yh, -yl);
      } else {
        return new Interval(yl, yh);
      }
    } else if (x.lo < 0) {
      if ((power & 1) === 1) {
        return new Interval(-round_default.powLo(-x.lo, power), round_default.powHi(x.hi, power));
      } else {
        return new Interval(0, round_default.powHi(Math.max(-x.lo, x.hi), power));
      }
    } else {
      return new Interval(round_default.powLo(x.lo, power), round_default.powHi(x.hi, power));
    }
  } else {
    console.warn("power is not an integer, you should use nth-root instead, returning an empty interval");
    return constants_default.EMPTY;
  }
}
function sqrt(x) {
  return nthRoot(x, 2);
}
function nthRoot(x, n) {
  if (isEmpty(x) || n < 0) {
    return constants_default.EMPTY;
  }
  if (typeof n === "object") {
    if (!isSingleton(n)) {
      return constants_default.EMPTY;
    }
    n = n.lo;
  }
  const power = 1 / n;
  if (x.hi < 0) {
    if (Number.isSafeInteger(n) && (n & 1) === 1) {
      const yl = round_default.powHi(-x.lo, power);
      const yh = round_default.powLo(-x.hi, power);
      return new Interval(-yl, -yh);
    }
    return constants_default.EMPTY;
  } else if (x.lo < 0) {
    const yp = round_default.powHi(x.hi, power);
    if (Number.isSafeInteger(n) && (n & 1) === 1) {
      const yn = -round_default.powHi(-x.lo, power);
      return new Interval(yn, yp);
    }
    return new Interval(0, yp);
  } else {
    return new Interval(round_default.powLo(x.lo, power), round_default.powHi(x.hi, power));
  }
}
var init_algebra = __esm({
  "node_modules/interval-arithmetic/lib-esm/operations/algebra.js"() {
    init_interval();
    init_round();
    init_constants();
    init_utils();
    init_arithmetic();
  }
});

// node_modules/interval-arithmetic/lib-esm/operations/misc.js
var misc_exports = {};
__export(misc_exports, {
  LOG_EXP_10: () => LOG_EXP_10,
  LOG_EXP_2: () => LOG_EXP_2,
  abs: () => abs,
  clone: () => clone,
  difference: () => difference,
  exp: () => exp,
  hull: () => hull,
  intersection: () => intersection,
  ln: () => ln,
  log: () => log,
  log10: () => log10,
  log2: () => log2,
  max: () => max,
  min: () => min,
  union: () => union,
  wid: () => wid,
  width: () => width
});
function exp(x) {
  if (isEmpty(x)) {
    return constants_default.EMPTY;
  }
  return new Interval(round_default.expLo(x.lo), round_default.expHi(x.hi));
}
function log(x) {
  if (isEmpty(x)) {
    return constants_default.EMPTY;
  }
  const l = x.lo <= 0 ? Number.NEGATIVE_INFINITY : round_default.logLo(x.lo);
  return new Interval(l, round_default.logHi(x.hi));
}
function log10(x) {
  if (isEmpty(x)) {
    return constants_default.EMPTY;
  }
  return div(log(x), LOG_EXP_10);
}
function log2(x) {
  if (isEmpty(x)) {
    return constants_default.EMPTY;
  }
  return div(log(x), LOG_EXP_2);
}
function hull(x, y) {
  const badX = isEmpty(x);
  const badY = isEmpty(y);
  if (badX && badY) {
    return constants_default.EMPTY;
  } else if (badX) {
    return y.clone();
  } else if (badY) {
    return x.clone();
  } else {
    return new Interval(Math.min(x.lo, y.lo), Math.max(x.hi, y.hi));
  }
}
function intersection(x, y) {
  if (isEmpty(x) || isEmpty(y)) {
    return constants_default.EMPTY;
  }
  const lo = Math.max(x.lo, y.lo);
  const hi = Math.min(x.hi, y.hi);
  if (lo <= hi) {
    return new Interval(lo, hi);
  }
  return constants_default.EMPTY;
}
function union(x, y) {
  if (!intervalsOverlap(x, y)) {
    throw Error("Interval#union: intervals do not overlap");
  }
  return new Interval(Math.min(x.lo, y.lo), Math.max(x.hi, y.hi));
}
function difference(x, y) {
  if (isEmpty(x) || isWhole(y)) {
    return constants_default.EMPTY;
  }
  if (intervalsOverlap(x, y)) {
    if (x.lo < y.lo && y.hi < x.hi) {
      throw Error("Interval.difference: difference creates multiple intervals");
    }
    if (y.lo <= x.lo && y.hi === Infinity || y.hi >= x.hi && y.lo === -Infinity) {
      return constants_default.EMPTY;
    }
    if (y.lo <= x.lo) {
      return new Interval().halfOpenLeft(y.hi, x.hi);
    }
    return new Interval().halfOpenRight(x.lo, y.lo);
  }
  return x.clone();
}
function width(x) {
  if (isEmpty(x)) {
    return 0;
  }
  return round_default.subHi(x.hi, x.lo);
}
function abs(x) {
  if (isEmpty(x) || isWhole(x)) {
    return constants_default.EMPTY;
  }
  if (x.lo >= 0) {
    return x.clone();
  }
  if (x.hi <= 0) {
    return negative2(x);
  }
  return new Interval(0, Math.max(-x.lo, x.hi));
}
function max(x, y) {
  const badX = isEmpty(x);
  const badY = isEmpty(y);
  if (badX && badY) {
    return constants_default.EMPTY;
  } else if (badX) {
    return y.clone();
  } else if (badY) {
    return x.clone();
  } else {
    return new Interval(Math.max(x.lo, y.lo), Math.max(x.hi, y.hi));
  }
}
function min(x, y) {
  const badX = isEmpty(x);
  const badY = isEmpty(y);
  if (badX && badY) {
    return constants_default.EMPTY;
  } else if (badX) {
    return y.clone();
  } else if (badY) {
    return x.clone();
  } else {
    return new Interval(Math.min(x.lo, y.lo), Math.min(x.hi, y.hi));
  }
}
function clone(x) {
  return new Interval().set(x.lo, x.hi);
}
var ln, LOG_EXP_10, LOG_EXP_2, wid;
var init_misc = __esm({
  "node_modules/interval-arithmetic/lib-esm/operations/misc.js"() {
    init_interval();
    init_round();
    init_constants();
    init_utils();
    init_arithmetic();
    ln = log;
    LOG_EXP_10 = log(new Interval(10, 10));
    LOG_EXP_2 = log(new Interval(2, 2));
    wid = width;
  }
});

// node_modules/interval-arithmetic/lib-esm/operations/trigonometric.js
var trigonometric_exports = {};
__export(trigonometric_exports, {
  acos: () => acos,
  asin: () => asin,
  atan: () => atan,
  cos: () => cos,
  cosh: () => cosh,
  sin: () => sin,
  sinh: () => sinh,
  tan: () => tan,
  tanh: () => tanh
});
function onlyInfinity(x) {
  return !isFinite(x.lo) && x.lo === x.hi;
}
function handleNegative(interval) {
  if (interval.lo < 0) {
    if (interval.lo === -Infinity) {
      interval.lo = 0;
      interval.hi = Infinity;
    } else {
      const n = Math.ceil(-interval.lo / constants_default.PI_TWICE_LOW);
      interval.lo += constants_default.PI_TWICE_LOW * n;
      interval.hi += constants_default.PI_TWICE_LOW * n;
    }
  }
  return interval;
}
function cos(x) {
  if (isEmpty(x) || onlyInfinity(x)) {
    return constants_default.EMPTY;
  }
  const cache2 = new Interval().set(x.lo, x.hi);
  handleNegative(cache2);
  const pi2 = constants_default.PI_TWICE;
  const t = fmod(cache2, pi2);
  if (width(t) >= pi2.lo) {
    return new Interval(-1, 1);
  }
  if (t.lo >= constants_default.PI_HIGH) {
    const cosv = cos(sub(t, constants_default.PI));
    return negative2(cosv);
  }
  const lo = t.lo;
  const hi = t.hi;
  const rlo = round_default.cosLo(hi);
  const rhi = round_default.cosHi(lo);
  if (hi <= constants_default.PI_LOW) {
    return new Interval(rlo, rhi);
  } else if (hi <= pi2.lo) {
    return new Interval(-1, Math.max(rlo, rhi));
  } else {
    return new Interval(-1, 1);
  }
}
function sin(x) {
  if (isEmpty(x) || onlyInfinity(x)) {
    return constants_default.EMPTY;
  }
  return cos(sub(x, constants_default.PI_HALF));
}
function tan(x) {
  if (isEmpty(x) || onlyInfinity(x)) {
    return constants_default.EMPTY;
  }
  const cache2 = new Interval().set(x.lo, x.hi);
  handleNegative(cache2);
  const pi = constants_default.PI;
  let t = fmod(cache2, pi);
  if (t.lo >= constants_default.PI_HALF_LOW) {
    t = sub(t, pi);
  }
  if (t.lo <= -constants_default.PI_HALF_LOW || t.hi >= constants_default.PI_HALF_LOW) {
    return constants_default.WHOLE;
  }
  return new Interval(round_default.tanLo(t.lo), round_default.tanHi(t.hi));
}
function asin(x) {
  if (isEmpty(x) || x.hi < -1 || x.lo > 1) {
    return constants_default.EMPTY;
  }
  const lo = x.lo <= -1 ? -constants_default.PI_HALF_HIGH : round_default.asinLo(x.lo);
  const hi = x.hi >= 1 ? constants_default.PI_HALF_HIGH : round_default.asinHi(x.hi);
  return new Interval(lo, hi);
}
function acos(x) {
  if (isEmpty(x) || x.hi < -1 || x.lo > 1) {
    return constants_default.EMPTY;
  }
  const lo = x.hi >= 1 ? 0 : round_default.acosLo(x.hi);
  const hi = x.lo <= -1 ? constants_default.PI_HIGH : round_default.acosHi(x.lo);
  return new Interval(lo, hi);
}
function atan(x) {
  if (isEmpty(x)) {
    return constants_default.EMPTY;
  }
  return new Interval(round_default.atanLo(x.lo), round_default.atanHi(x.hi));
}
function sinh(x) {
  if (isEmpty(x)) {
    return constants_default.EMPTY;
  }
  return new Interval(round_default.sinhLo(x.lo), round_default.sinhHi(x.hi));
}
function cosh(x) {
  if (isEmpty(x)) {
    return constants_default.EMPTY;
  }
  if (x.hi < 0) {
    return new Interval(round_default.coshLo(x.hi), round_default.coshHi(x.lo));
  } else if (x.lo >= 0) {
    return new Interval(round_default.coshLo(x.lo), round_default.coshHi(x.hi));
  } else {
    return new Interval(1, round_default.coshHi(-x.lo > x.hi ? x.lo : x.hi));
  }
}
function tanh(x) {
  if (isEmpty(x)) {
    return constants_default.EMPTY;
  }
  return new Interval(round_default.tanhLo(x.lo), round_default.tanhHi(x.hi));
}
var init_trigonometric = __esm({
  "node_modules/interval-arithmetic/lib-esm/operations/trigonometric.js"() {
    "use strict";
    init_interval();
    init_round();
    init_constants();
    init_utils();
    init_arithmetic();
    init_algebra();
    init_misc();
  }
});

// node_modules/interval-arithmetic/lib-esm/index.js
var lib_esm_exports = {};
__export(lib_esm_exports, {
  Interval: () => _Interval,
  LOG_EXP_10: () => LOG_EXP_10,
  LOG_EXP_2: () => LOG_EXP_2,
  abs: () => abs,
  acos: () => acos,
  add: () => add,
  almostEqual: () => almostEqual,
  asin: () => asin,
  assertIncludes: () => assertIncludes,
  atan: () => atan,
  clone: () => clone,
  constants: () => constants_default,
  cos: () => cos,
  cosh: () => cosh,
  default: () => lib_esm_default,
  difference: () => difference,
  div: () => div,
  divide: () => divide,
  equal: () => equal,
  exp: () => exp,
  fmod: () => fmod,
  geq: () => geq,
  greaterEqualThan: () => greaterEqualThan,
  greaterThan: () => greaterThan,
  gt: () => gt,
  hasInterval: () => hasInterval,
  hasValue: () => hasValue,
  hull: () => hull,
  intersection: () => intersection,
  intervalsOverlap: () => intervalsOverlap,
  isEmpty: () => isEmpty,
  isInterval: () => isInterval,
  isSingleton: () => isSingleton,
  isWhole: () => isWhole,
  leq: () => leq,
  lessEqualThan: () => lessEqualThan,
  lessThan: () => lessThan,
  ln: () => ln,
  log: () => log,
  log10: () => log10,
  log2: () => log2,
  lt: () => lt,
  max: () => max,
  min: () => min,
  mul: () => mul,
  multiplicativeInverse: () => multiplicativeInverse,
  multiply: () => multiply,
  negative: () => negative2,
  notEqual: () => notEqual,
  nthRoot: () => nthRoot,
  positive: () => positive2,
  pow: () => pow,
  round: () => round_default,
  sin: () => sin,
  sinh: () => sinh,
  sqrt: () => sqrt,
  sub: () => sub,
  subtract: () => subtract,
  tan: () => tan,
  tanh: () => tanh,
  union: () => union,
  wid: () => wid,
  width: () => width,
  zeroIn: () => zeroIn
});
var MixedInterval, lib_esm_default;
var init_lib_esm = __esm({
  "node_modules/interval-arithmetic/lib-esm/index.js"() {
    init_interval();
    init_round();
    init_constants();
    init_relational();
    init_arithmetic();
    init_algebra();
    init_trigonometric();
    init_misc();
    init_utils();
    init_relational();
    init_arithmetic();
    init_algebra();
    init_trigonometric();
    init_misc();
    init_utils();
    MixedInterval = Object.assign(Interval, constants_default, round_default, misc_exports, utils_exports, relational_exports, arithmetic_exports, algebra_exports, trigonometric_exports, { round: round_default });
    lib_esm_default = MixedInterval;
  }
});

// node_modules/interval-arithmetic-eval/lib/adapter.js
var require_adapter2 = __commonJS({
  "node_modules/interval-arithmetic-eval/lib/adapter.js"(exports, module) {
    "use strict";
    module.exports = function(ns) {
      ns.mod = ns.fmod;
      ns.lessThan = ns.lt;
      ns.lessEqualThan = ns.leq;
      ns.greaterThan = ns.gt;
      ns.greaterEqualThan = ns.geq;
      ns.strictlyEqual = ns.equal;
      ns.strictlyNotEqual = ns.notEqual;
      ns.logicalAND = function(a, b) {
        return a && b;
      };
      ns.logicalXOR = function(a, b) {
        return a ^ b;
      };
      ns.logicalOR = function(a, b) {
        return a || b;
      };
    };
  }
});

// node_modules/interval-arithmetic-eval/lib/policies.js
var require_policies = __commonJS({
  "node_modules/interval-arithmetic-eval/lib/policies.js"(exports, module) {
    "use strict";
    module.exports = function(Interval2) {
      return {
        disableRounding: function() {
          Interval2.round.disable();
        },
        enableRounding: function() {
          Interval2.round.enable();
        }
      };
    };
  }
});

// node_modules/interval-arithmetic-eval/lib/eval.js
var require_eval2 = __commonJS({
  "node_modules/interval-arithmetic-eval/lib/eval.js"(exports, module) {
    "use strict";
    var CodeGenerator = require_math_codegen2();
    var Interval2 = (init_lib_esm(), __toCommonJS(lib_esm_exports)).default;
    require_adapter2()(Interval2);
    function processScope(scope) {
      Object.keys(scope).forEach(function(k) {
        const value = scope[k];
        if (typeof value === "number" || Array.isArray(value)) {
          scope[k] = Interval2.factory(value);
        } else if (typeof value === "object" && "lo" in value && "hi" in value) {
          scope[k] = Interval2.factory(value.lo, value.hi);
        }
      });
    }
    module.exports = function(expression) {
      return new CodeGenerator().setDefs({
        $$processScope: processScope
      }).parse(expression).compile(Interval2);
    };
    module.exports.policies = require_policies()(Interval2);
    module.exports.Interval = Interval2;
  }
});

// node_modules/interval-arithmetic-eval/index.js
var require_interval_arithmetic_eval = __commonJS({
  "node_modules/interval-arithmetic-eval/index.js"(exports, module) {
    "use strict";
    module.exports = require_eval2();
  }
});

// node_modules/function-plot/dist/helpers/eval.js
var require_eval3 = __commonJS({
  "node_modules/function-plot/dist/helpers/eval.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.interval = exports.builtIn = void 0;
    var built_in_math_eval_1 = __importDefault(require_built_in_math_eval());
    var interval_arithmetic_eval_1 = __importDefault(require_interval_arithmetic_eval());
    var samplers = {
      interval: interval_arithmetic_eval_1.default,
      builtIn: built_in_math_eval_1.default
    };
    function getMathJS() {
      if (typeof global === "object" && "math" in global) {
        return global.math;
      }
      if (typeof window === "object" && "math" in window) {
        return window.math;
      }
      return null;
    }
    var mathJS = getMathJS();
    if (mathJS) {
      samplers.builtIn = mathJS.compile;
    }
    function generateEvaluator(samplerName) {
      function doCompile(expression) {
        if (typeof expression === "string") {
          const compiled = samplers[samplerName](expression);
          if (mathJS && samplerName === "builtIn") {
            return { eval: compiled.evaluate || compiled.eval };
          }
          return compiled;
        } else if (typeof expression === "function") {
          return { eval: expression };
        } else {
          throw Error("expression must be a string or a function");
        }
      }
      function compileIfPossible(meta, property) {
        const expression = meta[property];
        const hiddenProperty = samplerName + "_Expression_" + property;
        const hiddenCompiled = samplerName + "_Compiled_" + property;
        if (expression !== meta[hiddenProperty]) {
          meta[hiddenProperty] = expression;
          meta[hiddenCompiled] = doCompile(expression);
        }
      }
      function getCompiledExpression(meta, property) {
        return meta[samplerName + "_Compiled_" + property];
      }
      function evaluate(meta, property, variables) {
        compileIfPossible(meta, property);
        return getCompiledExpression(meta, property).eval(Object.assign({}, meta.scope || {}, variables));
      }
      return evaluate;
    }
    var builtIn = generateEvaluator("builtIn");
    exports.builtIn = builtIn;
    var interval = generateEvaluator("interval");
    exports.interval = interval;
  }
});

// node_modules/function-plot/dist/tip.js
var require_tip = __commonJS({
  "node_modules/function-plot/dist/tip.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_shape_1 = (init_src(), __toCommonJS(src_exports));
    var d3_selection_1 = (init_src7(), __toCommonJS(src_exports7));
    var utils_1 = __importDefault(require_utils());
    var globals_1 = __importDefault(require_globals());
    var eval_1 = require_eval3();
    function mouseTip(config) {
      config = Object.assign({
        xLine: false,
        yLine: false,
        renderer: function(x, y) {
          return "(" + x.toFixed(3) + ", " + y.toFixed(3) + ")";
        },
        owner: null
      }, config);
      const MARGIN = 20;
      const line = (0, d3_shape_1.line)().x(function(d) {
        return d[0];
      }).y(function(d) {
        return d[1];
      });
      function lineGenerator(el, data) {
        return el.append("path").datum(data).attr("stroke", "grey").attr("stroke-dasharray", "5,5").attr("opacity", 0.5).attr("d", line);
      }
      let tipInnerJoin, tipInnerEnter;
      function tip(selection) {
        const join = selection.selectAll("g.tip").data(function(d) {
          return [d];
        });
        const tipEnter = join.enter().append("g").attr("class", "tip").attr("clip-path", "url(#function-plot-clip-" + config.owner.id + ")");
        tipInnerJoin = join.merge(tipEnter).selectAll("g.inner-tip").data(function(d) {
          return [d];
        });
        tipInnerEnter = tipInnerJoin.enter().append("g").attr("class", "inner-tip").style("display", "none").each(function() {
          const el = (0, d3_selection_1.select)(this);
          lineGenerator(el, [
            [0, -config.owner.meta.height - MARGIN],
            [0, config.owner.meta.height + MARGIN]
          ]).attr("class", "tip-x-line").style("display", "none");
          lineGenerator(el, [
            [-config.owner.meta.width - MARGIN, 0],
            [config.owner.meta.width + MARGIN, 0]
          ]).attr("class", "tip-y-line").style("display", "none");
          el.append("circle").attr("r", 3);
          el.append("text").attr("transform", "translate(5,-5)");
        });
        tipInnerJoin.merge(tipInnerEnter).selectAll(".tip-x-line").style("display", config.xLine ? null : "none");
        tipInnerJoin.merge(tipInnerEnter).selectAll(".tip-y-line").style("display", config.yLine ? null : "none");
      }
      tip.move = function(coordinates) {
        let i;
        let minDist = Infinity;
        let closestIndex = -1;
        let x, y;
        const selection = tipInnerJoin.merge(tipInnerEnter);
        const meta = config.owner.meta;
        const data = selection.datum().data;
        const xScale = meta.xScale;
        const yScale = meta.yScale;
        const width2 = meta.width;
        const height = meta.height;
        const x0 = coordinates.x;
        const y0 = coordinates.y;
        for (i = 0; i < data.length; i += 1) {
          if (data[i].skipTip || data[i].fnType !== "linear") {
            continue;
          }
          const range = data[i].range || [-utils_1.default.infinity(), utils_1.default.infinity()];
          let candidateY;
          if (x0 > range[0] - globals_1.default.TIP_X_EPS && x0 < range[1] + globals_1.default.TIP_X_EPS) {
            try {
              candidateY = (0, eval_1.builtIn)(data[i], "fn", { x: x0 });
            } catch (e) {
            }
            if (utils_1.default.isValidNumber(candidateY)) {
              const tDist = Math.abs(candidateY - y0);
              if (tDist < minDist) {
                minDist = tDist;
                closestIndex = i;
              }
            }
          }
        }
        if (closestIndex !== -1) {
          x = x0;
          if (data[closestIndex].range) {
            x = Math.max(x, data[closestIndex].range[0]);
            x = Math.min(x, data[closestIndex].range[1]);
          }
          y = (0, eval_1.builtIn)(data[closestIndex], "fn", { x });
          tip.show();
          config.owner.emit("tip:update", { x, y, index: closestIndex });
          const clampX = utils_1.default.clamp(x, xScale.invert(-MARGIN), xScale.invert(width2 + MARGIN));
          const clampY = utils_1.default.clamp(y, yScale.invert(height + MARGIN), yScale.invert(-MARGIN));
          const color = utils_1.default.color(data[closestIndex], closestIndex);
          selection.style("color", "red");
          selection.attr("transform", "translate(" + xScale(clampX) + "," + yScale(clampY) + ")");
          selection.select("circle").attr("fill", color);
          selection.select("text").attr("fill", color).text(config.renderer(x, y, closestIndex));
        } else {
          tip.hide();
        }
      };
      tip.show = function() {
        tipInnerJoin.merge(tipInnerEnter).style("display", null);
      };
      tip.hide = function() {
        tipInnerJoin.merge(tipInnerEnter).style("display", "none");
      };
      Object.keys(config).forEach(function(option) {
        utils_1.default.getterSetter.call(tip, config, option);
      });
      return tip;
    }
    exports.default = mouseTip;
  }
});

// node_modules/function-plot/dist/samplers/interval.js
var require_interval = __commonJS({
  "node_modules/function-plot/dist/samplers/interval.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var interval_arithmetic_eval_1 = __importStar(require_interval_arithmetic_eval());
    var eval_1 = require_eval3();
    var utils_1 = __importDefault(require_utils());
    interval_arithmetic_eval_1.default.policies.disableRounding();
    function interval1d(samplerParams) {
      const xCoords = utils_1.default.space(samplerParams.xAxis, samplerParams.range, samplerParams.nSamples);
      const xScale = samplerParams.xScale;
      const yScale = samplerParams.yScale;
      const yMin = yScale.domain()[0];
      const yMax = yScale.domain()[1];
      const samples = [];
      let i;
      for (i = 0; i < xCoords.length - 1; i += 1) {
        const x = { lo: xCoords[i], hi: xCoords[i + 1] };
        const y = (0, eval_1.interval)(samplerParams.d, "fn", { x });
        if (!interval_arithmetic_eval_1.Interval.isEmpty(y) && !interval_arithmetic_eval_1.Interval.isWhole(y)) {
          samples.push([x, y]);
        }
        if (interval_arithmetic_eval_1.Interval.isWhole(y)) {
          samples.push(null);
        }
      }
      for (i = 1; i < samples.length - 1; i += 1) {
        if (!samples[i]) {
          const prev2 = samples[i - 1];
          const next2 = samples[i + 1];
          if (prev2 && next2 && !interval_arithmetic_eval_1.Interval.intervalsOverlap(prev2[1], next2[1])) {
            if (prev2[1].lo > next2[1].hi) {
              prev2[1].hi = Math.max(yMax, prev2[1].hi);
              next2[1].lo = Math.min(yMin, next2[1].lo);
            }
            if (prev2[1].hi < next2[1].lo) {
              prev2[1].lo = Math.min(yMin, prev2[1].lo);
              next2[1].hi = Math.max(yMax, next2[1].hi);
            }
          }
        }
      }
      ;
      samples.scaledDx = xScale(xCoords[1]) - xScale(xCoords[0]);
      return [samples];
    }
    var rectEps;
    function smallRect(x, y) {
      return interval_arithmetic_eval_1.Interval.width(x) < rectEps;
    }
    function quadTree(x, y, d) {
      const sample = (0, eval_1.interval)(d, "fn", { x, y });
      const fulfills = interval_arithmetic_eval_1.Interval.zeroIn(sample);
      if (!fulfills) {
        return this;
      }
      if (smallRect(x, y)) {
        this.push([x, y]);
        return this;
      }
      const midX = x.lo + (x.hi - x.lo) / 2;
      const midY = y.lo + (y.hi - y.lo) / 2;
      const east = { lo: midX, hi: x.hi };
      const west = { lo: x.lo, hi: midX };
      const north = { lo: midY, hi: y.hi };
      const south = { lo: y.lo, hi: midY };
      quadTree.call(this, east, north, d);
      quadTree.call(this, east, south, d);
      quadTree.call(this, west, north, d);
      quadTree.call(this, west, south, d);
    }
    function interval2d(samplerParams) {
      const xScale = samplerParams.xScale;
      const xDomain = samplerParams.xScale.domain();
      const yDomain = samplerParams.yScale.domain();
      const x = { lo: xDomain[0], hi: xDomain[1] };
      const y = { lo: yDomain[0], hi: yDomain[1] };
      const samples = [];
      rectEps = xScale.invert(1) - xScale.invert(0);
      quadTree.call(samples, x, y, samplerParams.d);
      samples.scaledDx = 1;
      return [samples];
    }
    var sampler = function sampler2(samplerParams) {
      const fnTypes = {
        implicit: interval2d,
        linear: interval1d
      };
      if (!Object.hasOwn(fnTypes, samplerParams.d.fnType)) {
        throw Error(samplerParams.d.fnType + " is not supported in the `interval` sampler");
      }
      return fnTypes[samplerParams.d.fnType].apply(null, arguments);
    };
    exports.default = sampler;
  }
});

// node_modules/function-plot/dist/samplers/builtIn.js
var require_builtIn = __commonJS({
  "node_modules/function-plot/dist/samplers/builtIn.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = __importDefault(require_utils());
    var eval_1 = require_eval3();
    function checkAsymptote(d0, d1, d, sign, level) {
      if (!level) {
        return { asymptote: true, d0, d1 };
      }
      const n = 10;
      const x0 = d0[0];
      const x1 = d1[0];
      const samples = utils_1.default.linspace(x0, x1, n);
      let oldY, oldX;
      for (let i = 0; i < n; i += 1) {
        const x = samples[i];
        const y = (0, eval_1.builtIn)(d, "fn", { x });
        if (oldY) {
          const deltaY = y - oldY;
          const newSign = utils_1.default.sgn(deltaY);
          if (newSign === sign) {
            return checkAsymptote([oldX, oldY], [x, y], d, sign, level - 1);
          }
        }
        oldY = y;
        oldX = x;
      }
      return { asymptote: false, d0, d1 };
    }
    function split(d, data, yScale) {
      let oldSign;
      const evalResult = [];
      const yMin = yScale.domain()[0] - utils_1.default.infinity();
      const yMax = yScale.domain()[1] + utils_1.default.infinity();
      let evalGroup = [data[0]];
      let i = 1;
      let deltaX = utils_1.default.infinity();
      while (i < data.length) {
        const yOld = data[i - 1][1];
        const yNew = data[i][1];
        const deltaY = yNew - yOld;
        const newSign = utils_1.default.sgn(deltaY);
        if (
          // we have at least 2 entries (so that we can compute deltaY)
          evalGroup.length >= 2 && // utils.sgn(y1) * utils.sgn(y0) < 0 && // there's a change in the evaluated values sign
          // there's a change in the slope sign
          oldSign !== newSign && // the slope is bigger to some value (according to the current zoom scale)
          Math.abs(deltaY / deltaX) > 1
        ) {
          const check = checkAsymptote(data[i - 1], data[i], d, newSign, 3);
          if (check.asymptote) {
            data[i - 1][0] = check.d0[0];
            data[i - 1][1] = utils_1.default.clamp(check.d0[1], yMin, yMax);
            evalResult.push(evalGroup);
            data[i][0] = check.d1[0];
            data[i][1] = utils_1.default.clamp(check.d1[1], yMin, yMax);
            evalGroup = [data[i]];
          } else {
            evalGroup.push(data[i]);
          }
        } else {
          evalGroup.push(data[i]);
        }
        if (evalGroup.length > 1) {
          deltaX = evalGroup[evalGroup.length - 1][0] - evalGroup[evalGroup.length - 2][0];
          oldSign = newSign;
        }
        ++i;
      }
      if (evalGroup.length) {
        evalResult.push(evalGroup);
      }
      return evalResult;
    }
    function linear(samplerParams) {
      const allX = utils_1.default.space(samplerParams.xAxis, samplerParams.range, samplerParams.nSamples);
      const yDomain = samplerParams.yScale.domain();
      const yMin = yDomain[0] - utils_1.default.infinity();
      const yMax = yDomain[1] + utils_1.default.infinity();
      const data = [];
      for (let i = 0; i < allX.length; i += 1) {
        const x = allX[i];
        let y = (0, eval_1.builtIn)(samplerParams.d, "fn", { x });
        if (utils_1.default.isValidNumber(x) && utils_1.default.isValidNumber(y)) {
          y = utils_1.default.clamp(y, yMin, yMax);
          data.push([x, y]);
        }
      }
      const splitData = split(samplerParams.d, data, samplerParams.yScale);
      return splitData;
    }
    function parametric(samplerParams) {
      const parametricRange = samplerParams.d.range || [0, 2 * Math.PI];
      const tCoords = utils_1.default.space(samplerParams.xAxis, parametricRange, samplerParams.nSamples);
      const samples = [];
      for (let i = 0; i < tCoords.length; i += 1) {
        const t = tCoords[i];
        const x = (0, eval_1.builtIn)(samplerParams.d, "x", { t });
        const y = (0, eval_1.builtIn)(samplerParams.d, "y", { t });
        samples.push([x, y]);
      }
      return [samples];
    }
    function polar(samplerParams) {
      const polarRange = samplerParams.d.range || [-Math.PI, Math.PI];
      const thetaSamples = utils_1.default.space(samplerParams.xAxis, polarRange, samplerParams.nSamples);
      const samples = [];
      for (let i = 0; i < thetaSamples.length; i += 1) {
        const theta = thetaSamples[i];
        const r = (0, eval_1.builtIn)(samplerParams.d, "r", { theta });
        const x = r * Math.cos(theta);
        const y = r * Math.sin(theta);
        samples.push([x, y]);
      }
      return [samples];
    }
    function points(samplerParams) {
      return [samplerParams.d.points];
    }
    function vector(sampleParams) {
      const d = sampleParams.d;
      d.offset = d.offset || [0, 0];
      return [[d.offset, [d.vector[0] + d.offset[0], d.vector[1] + d.offset[1]]]];
    }
    var sampler = function sampler2(samplerParams) {
      const fnTypes = {
        parametric,
        polar,
        points,
        vector,
        linear
      };
      if (!(samplerParams.d.fnType in fnTypes)) {
        throw Error(samplerParams.d.fnType + " is not supported in the `builtIn` sampler");
      }
      return fnTypes[samplerParams.d.fnType].apply(null, arguments);
    };
    exports.default = sampler;
  }
});

// node_modules/function-plot/dist/evaluate.js
var require_evaluate = __commonJS({
  "node_modules/function-plot/dist/evaluate.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var globals_1 = __importDefault(require_globals());
    var interval_1 = __importDefault(require_interval());
    var builtIn_1 = __importDefault(require_builtIn());
    function computeEndpoints(scale, d) {
      const range = d.range || [-Infinity, Infinity];
      const start = Math.max(scale.domain()[0], range[0]);
      const end = Math.min(scale.domain()[1], range[1]);
      return [start, end];
    }
    function evaluate(chart, d) {
      const range = computeEndpoints(chart.meta.xScale, d);
      let samplerFn;
      if (d.sampler === "builtIn") {
        samplerFn = builtIn_1.default;
      } else if (d.sampler === "interval") {
        samplerFn = interval_1.default;
      } else {
        throw new Error(`Invalid sampler function ${d.sampler}`);
      }
      const nSamples = d.nSamples || Math.min(globals_1.default.MAX_ITERATIONS, globals_1.default.DEFAULT_ITERATIONS || chart.meta.width * 2);
      const data = samplerFn({
        d,
        range,
        xScale: chart.meta.xScale,
        yScale: chart.meta.yScale,
        xAxis: chart.options.xAxis,
        yAxis: chart.options.yAxis,
        nSamples
      });
      chart.emit("eval", data, d.index, d.isHelper);
      return data;
    }
    exports.default = evaluate;
  }
});

// node_modules/function-plot/dist/graph-types/polyline.js
var require_polyline = __commonJS({
  "node_modules/function-plot/dist/graph-types/polyline.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_selection_1 = (init_src7(), __toCommonJS(src_exports7));
    var d3_shape_1 = (init_src(), __toCommonJS(src_exports));
    var utils_1 = __importDefault(require_utils());
    var evaluate_1 = __importDefault(require_evaluate());
    function polyline(chart) {
      function plotLine(selection) {
        selection.each(function(d) {
          const el = plotLine.el = (0, d3_selection_1.select)(this);
          const index = d.index;
          const evaluatedData = (0, evaluate_1.default)(chart, d);
          const color = utils_1.default.color(d, index);
          const innerSelection = el.selectAll(":scope > path.line").data(evaluatedData);
          const yRange = chart.meta.yScale.range();
          let yMax = yRange[0];
          let yMin = yRange[1];
          const diff = yMax - yMin;
          yMax += diff * 1e6;
          yMin -= diff * 1e6;
          if (d.skipBoundsCheck) {
            yMax = utils_1.default.infinity();
            yMin = -utils_1.default.infinity();
          }
          function y(d2) {
            return utils_1.default.clamp(chart.meta.yScale(d2[1]), yMin, yMax);
          }
          const line = (0, d3_shape_1.line)().curve(d3_shape_1.curveLinear).x(function(d2) {
            return chart.meta.xScale(d2[0]);
          }).y(y);
          const area = (0, d3_shape_1.area)().x(function(d2) {
            return chart.meta.xScale(d2[0]);
          }).y0(chart.meta.yScale(0)).y1(y);
          const cls = `line line-${index}`;
          const innerSelectionEnter = innerSelection.enter().append("path").attr("class", cls).attr("stroke-width", 1).attr("stroke-linecap", "round");
          innerSelection.merge(innerSelectionEnter).each(function() {
            const path = (0, d3_selection_1.select)(this);
            let pathD;
            if (d.closed) {
              path.attr("fill", color);
              path.attr("fill-opacity", 0.3);
              pathD = area;
            } else {
              path.attr("fill", "none");
              pathD = line;
            }
            path.attr("stroke", color).attr("marker-end", function() {
              return d.fnType === "vector" ? "url(#" + chart.markerId + ")" : null;
            }).attr("d", pathD);
            if (d.attr) {
              for (const k in d.attr) {
                let val = d.attr[k];
                if (k === "class") {
                  val = `${cls} ${d.attr[k]}`;
                }
                path.attr(k, val);
              }
            }
          });
          innerSelection.exit().remove();
        });
      }
      return plotLine;
    }
    exports.default = polyline;
  }
});

// node_modules/function-plot/dist/graph-types/interval.js
var require_interval2 = __commonJS({
  "node_modules/function-plot/dist/graph-types/interval.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_selection_1 = (init_src7(), __toCommonJS(src_exports7));
    var evaluate_1 = __importDefault(require_evaluate());
    var utils_1 = __importDefault(require_utils());
    function interval(chart) {
      let minWidthHeight;
      const xScale = chart.meta.xScale;
      const yScale = chart.meta.yScale;
      function clampRange(vLo, vHi, gLo, gHi) {
        if (gLo > gHi) {
          const t = gLo;
          gLo = gHi;
          gHi = t;
        }
        const hi = Math.min(vHi, gHi);
        const lo = Math.max(vLo, gLo);
        if (lo > hi) {
          return [-minWidthHeight, 0];
        }
        return [lo, hi];
      }
      const line = function(points, closed) {
        let path = "";
        const range = yScale.range();
        const minY = Math.min.apply(Math, range);
        const maxY = Math.max.apply(Math, range);
        for (let i = 0, length = points.length; i < length; i += 1) {
          if (points[i]) {
            const x = points[i][0];
            const y = points[i][1];
            let yLo = y.lo;
            let yHi = y.hi;
            if (closed) {
              yLo = Math.min(yLo, 0);
              yHi = Math.max(yHi, 0);
            }
            const moveX = xScale(x.lo) + points.scaledDx / 2;
            const viewportY = clampRange(minY, maxY, isFinite(yHi) ? yScale(yHi) : -Infinity, isFinite(yLo) ? yScale(yLo) : Infinity);
            const vLo = viewportY[0];
            const vHi = viewportY[1];
            path += " M " + moveX + " " + vLo;
            path += " v " + Math.max(vHi - vLo, minWidthHeight);
          }
        }
        return path;
      };
      function plotLine(selection) {
        selection.each(function(d) {
          const el = plotLine.el = (0, d3_selection_1.select)(this);
          const index = d.index;
          const closed = d.closed;
          const evaluatedData = (0, evaluate_1.default)(chart, d);
          const innerSelection = el.selectAll(":scope > path.line").data(evaluatedData);
          minWidthHeight = Math.max(evaluatedData[0].scaledDx, 1);
          const cls = `line line-${index}`;
          const innerSelectionEnter = innerSelection.enter().append("path").attr("class", cls).attr("fill", "none");
          const selection2 = innerSelection.merge(innerSelectionEnter).attr("stroke-width", minWidthHeight).attr("stroke", utils_1.default.color(d, index)).attr("opacity", closed ? 0.5 : 1).attr("d", function(d2) {
            return line(d2, closed);
          });
          if (d.attr) {
            for (const k in d.attr) {
              let val = d.attr[k];
              if (k === "class") {
                val = `${cls} ${d.attr[k]}`;
              }
              selection2.attr(k, val);
            }
          }
          innerSelection.exit().remove();
        });
      }
      return plotLine;
    }
    exports.default = interval;
  }
});

// node_modules/function-plot/dist/graph-types/scatter.js
var require_scatter = __commonJS({
  "node_modules/function-plot/dist/graph-types/scatter.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_selection_1 = (init_src7(), __toCommonJS(src_exports7));
    var d3_color_1 = (init_src3(), __toCommonJS(src_exports3));
    var utils_1 = __importDefault(require_utils());
    var evaluate_1 = __importDefault(require_evaluate());
    function Scatter(chart) {
      const xScale = chart.meta.xScale;
      const yScale = chart.meta.yScale;
      function scatter(selection) {
        selection.each(function(d) {
          let i, j;
          const index = d.index;
          const color = utils_1.default.color(d, index);
          const evaluatedData = (0, evaluate_1.default)(chart, d);
          const joined = [];
          for (i = 0; i < evaluatedData.length; i += 1) {
            for (j = 0; j < evaluatedData[i].length; j += 1) {
              joined.push(evaluatedData[i][j]);
            }
          }
          const innerSelection = (0, d3_selection_1.select)(this).selectAll(":scope > circle.scatter").data(joined);
          const cls = `scatter scatter-${index}`;
          const innerSelectionEnter = innerSelection.enter().append("circle").attr("class", cls);
          const selection2 = innerSelection.merge(innerSelectionEnter).attr("fill", (0, d3_color_1.hsl)(color.toString()).brighter(1.5).formatHex()).attr("stroke", color).attr("opacity", 0.7).attr("r", 1).attr("cx", function(d2) {
            return xScale(d2[0]);
          }).attr("cy", function(d2) {
            return yScale(d2[1]);
          });
          if (d.attr) {
            for (const k in d.attr) {
              let val = d.attr[k];
              if (k === "class") {
                val = `${cls} ${d.attr[k]}`;
              }
              selection2.attr(k, val);
            }
          }
          innerSelection.exit().remove();
        });
      }
      return scatter;
    }
    exports.default = Scatter;
  }
});

// node_modules/function-plot/dist/graph-types/text.js
var require_text = __commonJS({
  "node_modules/function-plot/dist/graph-types/text.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_selection_1 = (init_src7(), __toCommonJS(src_exports7));
    var d3_color_1 = (init_src3(), __toCommonJS(src_exports3));
    var utils_1 = __importDefault(require_utils());
    function Text(chart) {
      const xScale = chart.meta.xScale;
      const yScale = chart.meta.yScale;
      function text(selection) {
        selection.each(function(d) {
          d.sampler = "builtIn";
          d.fnType = "vector";
          const innerSelection = (0, d3_selection_1.select)(this).selectAll(":scope > text.fn-text").data([d.location]);
          const innerSelectionEnter = innerSelection.enter().append("text").attr("class", `fn-text fn-text-${d.index}`);
          const color = utils_1.default.color(d, d.index);
          const selection2 = innerSelection.merge(innerSelectionEnter).attr("fill", (0, d3_color_1.hsl)(color.toString()).brighter(1.5).formatHex()).attr("x", (d2) => xScale(d2[0])).attr("y", (d2) => yScale(d2[1])).text(() => d.text);
          if (d.attr) {
            for (const k in d.attr) {
              selection2.attr(k, d.attr[k]);
            }
          }
          innerSelection.exit().remove();
        });
      }
      return text;
    }
    exports.default = Text;
  }
});

// node_modules/function-plot/dist/graph-types/index.js
var require_graph_types = __commonJS({
  "node_modules/function-plot/dist/graph-types/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.text = exports.scatter = exports.interval = exports.polyline = void 0;
    var polyline_1 = __importDefault(require_polyline());
    exports.polyline = polyline_1.default;
    var interval_1 = __importDefault(require_interval2());
    exports.interval = interval_1.default;
    var scatter_1 = __importDefault(require_scatter());
    exports.scatter = scatter_1.default;
    var text_1 = __importDefault(require_text());
    exports.text = text_1.default;
  }
});

// node_modules/function-plot/dist/datum-defaults.js
var require_datum_defaults = __commonJS({
  "node_modules/function-plot/dist/datum-defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function datumDefaults(d) {
      if (!("graphType" in d)) {
        d.graphType = "interval";
      }
      if (!("sampler" in d)) {
        d.sampler = d.graphType !== "interval" ? "builtIn" : "interval";
      }
      if (!("fnType" in d)) {
        d.fnType = "linear";
      }
      return d;
    }
    exports.default = datumDefaults;
  }
});

// node_modules/function-plot/dist/helpers/derivative.js
var require_derivative = __commonJS({
  "node_modules/function-plot/dist/helpers/derivative.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_selection_1 = (init_src7(), __toCommonJS(src_exports7));
    var graph_types_1 = require_graph_types();
    var eval_1 = require_eval3();
    var datum_defaults_1 = __importDefault(require_datum_defaults());
    var utils_1 = __importDefault(require_utils());
    function derivative(chart) {
      const derivativeDatum = (0, datum_defaults_1.default)({
        isHelper: true,
        skipTip: true,
        skipBoundsCheck: true,
        nSamples: 2,
        graphType: "polyline"
      });
      function computeLine(d) {
        if (!d.derivative) {
          return [];
        }
        const x0 = typeof d.derivative.x0 === "number" ? d.derivative.x0 : utils_1.default.infinity();
        derivativeDatum.index = d.index;
        derivativeDatum.scope = {
          m: (0, eval_1.builtIn)(d.derivative, "fn", { x: x0 }),
          x0,
          y0: (0, eval_1.builtIn)(d, "fn", { x: x0 })
        };
        derivativeDatum.fn = "m * (x - x0) + y0";
        return [derivativeDatum];
      }
      function checkAutoUpdate(d) {
        const self = this;
        if (!d.derivative) {
          return;
        }
        if (d.derivative.updateOnMouseMove && !d.derivative.$$mouseListener) {
          d.derivative.$$mouseListener = function({ x }) {
            if (d.derivative) {
              d.derivative.x0 = x;
            }
            derivative2(self);
          };
          chart.on("tip:update", d.derivative.$$mouseListener);
        }
      }
      const derivative2 = function(selection) {
        selection.each(function(d) {
          const el = (0, d3_selection_1.select)(this);
          const data = computeLine.call(selection, d);
          checkAutoUpdate.call(selection, d);
          const innerSelection = el.selectAll("g.derivative").data(data);
          const innerSelectionEnter = innerSelection.enter().append("g").attr("class", "derivative");
          innerSelection.merge(innerSelectionEnter).call((0, graph_types_1.polyline)(chart));
          innerSelection.merge(innerSelectionEnter).selectAll("path").attr("opacity", 0.5);
          innerSelection.exit().remove();
        });
      };
      return derivative2;
    }
    exports.default = derivative;
  }
});

// node_modules/function-plot/dist/helpers/secant.js
var require_secant = __commonJS({
  "node_modules/function-plot/dist/helpers/secant.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_selection_1 = (init_src7(), __toCommonJS(src_exports7));
    var eval_1 = require_eval3();
    var datum_defaults_1 = __importDefault(require_datum_defaults());
    var graph_types_1 = require_graph_types();
    var utils_1 = __importDefault(require_utils());
    function secant(chart) {
      const secantDefaults = (0, datum_defaults_1.default)({
        isHelper: true,
        skipTip: true,
        skipBoundsCheck: true,
        nSamples: 2,
        graphType: "polyline"
      });
      function computeSlope(scope) {
        scope.m = (scope.y1 - scope.y0) / (scope.x1 - scope.x0);
      }
      function updateLine(d, secant3) {
        if (!("x0" in secant3)) {
          throw Error("secant must have the property `x0` defined");
        }
        secant3.scope = secant3.scope || {};
        const x0 = secant3.x0;
        const x1 = typeof secant3.x1 === "number" ? secant3.x1 : utils_1.default.infinity();
        Object.assign(secant3.scope, {
          x0,
          x1,
          y0: (0, eval_1.builtIn)(d, "fn", { x: x0 }),
          y1: (0, eval_1.builtIn)(d, "fn", { x: x1 })
        });
        computeSlope(secant3.scope);
      }
      function setFn(d, secant3) {
        updateLine(d, secant3);
        secant3.fn = "m * (x - x0) + y0";
      }
      function setMouseListener(d, secantObject) {
        const self = this;
        if (secantObject.updateOnMouseMove && !secantObject.$$mouseListener) {
          secantObject.$$mouseListener = function({ x }) {
            secantObject.x1 = x;
            updateLine(d, secantObject);
            secant2(self);
          };
          chart.on("tip:update", secantObject.$$mouseListener);
        }
      }
      function computeLines(d) {
        const self = this;
        const data = [];
        d.secants = d.secants || [];
        for (let i = 0; i < d.secants.length; i += 1) {
          const secant3 = d.secants[i] = Object.assign({}, secantDefaults, d.secants[i]);
          secant3.index = d.index;
          if (!secant3.fn) {
            setFn.call(self, d, secant3);
            setMouseListener.call(self, d, secant3);
          }
          data.push(secant3);
        }
        return data;
      }
      function secant2(selection) {
        selection.each(function(d) {
          const el = (0, d3_selection_1.select)(this);
          const data = computeLines.call(selection, d);
          const innerSelection = el.selectAll("g.secant").data(data);
          const innerSelectionEnter = innerSelection.enter().append("g").attr("class", "secant");
          innerSelection.merge(innerSelectionEnter).call((0, graph_types_1.polyline)(chart));
          innerSelection.merge(innerSelectionEnter).selectAll("path").attr("opacity", 0.5);
          innerSelection.exit().remove();
        });
      }
      return secant2;
    }
    exports.default = secant;
  }
});

// node_modules/function-plot/dist/helpers/index.js
var require_helpers = __commonJS({
  "node_modules/function-plot/dist/helpers/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var d3_selection_1 = (init_src7(), __toCommonJS(src_exports7));
    var derivative_1 = __importDefault(require_derivative());
    var secant_1 = __importDefault(require_secant());
    function helpers(chart) {
      function helper(selection) {
        selection.each(function() {
          const el = (0, d3_selection_1.select)(this);
          el.call((0, derivative_1.default)(chart));
          el.call((0, secant_1.default)(chart));
        });
      }
      return helper;
    }
    exports.default = helpers;
  }
});

// node_modules/function-plot/dist/chart.js
var require_chart = __commonJS({
  "node_modules/function-plot/dist/chart.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Chart = void 0;
    var d3_shape_1 = (init_src(), __toCommonJS(src_exports));
    var d3_format_1 = (init_src2(), __toCommonJS(src_exports2));
    var d3_scale_1 = (init_src5(), __toCommonJS(src_exports5));
    var d3_axis_1 = (init_src6(), __toCommonJS(src_exports6));
    var d3_zoom_1 = (init_src8(), __toCommonJS(src_exports8));
    var d3_selection_1 = (init_src7(), __toCommonJS(src_exports7));
    var d3_interpolate_1 = (init_src4(), __toCommonJS(src_exports4));
    var events_1 = __importDefault(require_events());
    var annotations_1 = __importDefault(require_annotations());
    var tip_1 = __importDefault(require_tip());
    var helpers_1 = __importDefault(require_helpers());
    var datum_defaults_1 = __importDefault(require_datum_defaults());
    var globals_1 = __importDefault(require_globals());
    function getD3Scale(type) {
      if (type === "linear")
        return d3_scale_1.scaleLinear;
      return d3_scale_1.scaleLog;
    }
    var Chart = class _Chart extends events_1.default.EventEmitter {
      constructor(options) {
        super();
        const n = Math.random();
        const letter = String.fromCharCode(Math.floor(n * 26) + 97);
        this.options = options;
        this.id = letter + n.toString(16).substr(2);
        this.options.id = this.id;
        this.markerId = this.id + "-marker";
        _Chart.cache[this.id] = this;
        this.linkedGraphs = [this];
        this.meta = {};
        this.setUpEventListeners();
      }
      /**
       * Rebuilds the entire graph from scratch recomputing
       *
       * - the inner width/height
       * - scales/axes
       *
       * After this is done it does a complete redraw of all the datums,
       * if only the datums need to be redrawn call `instance.draw()` instead
       *
       * @returns Chart
       */
      build() {
        this.internalVars();
        this.drawGraphWrapper();
        return this;
      }
      getDraggableNode() {
        return (0, d3_selection_1.select)(this.options.target).select(".zoom-and-drag").node();
      }
      /**
       * The draggable container won't change across different instances of Chart,
       * therefore multiple instances will share the draggable container, to avoid dispatching
       * the event from the old instance grab it in runtime with this function
       */
      getEmitInstance() {
        let cachedInstance = this;
        const cachedNode = this.getDraggableNode();
        if (cachedNode) {
          cachedInstance = cachedNode.instance;
        }
        return cachedInstance;
      }
      internalVars() {
        const margin = this.meta.margin = { left: 40, right: 20, top: 20, bottom: 20 };
        if (this.options.title) {
          this.meta.margin.top = 40;
        }
        this.meta.width = (this.options.width || globals_1.default.DEFAULT_WIDTH) - margin.left - margin.right;
        this.meta.height = (this.options.height || globals_1.default.DEFAULT_HEIGHT) - margin.top - margin.bottom;
        this.initializeAxes();
      }
      initializeAxes() {
        const self = this;
        const integerFormat = (0, d3_format_1.format)("~s");
        function formatter(d) {
          const frac = Math.abs(d) - Math.floor(Math.abs(d));
          if (frac > 0) {
            return d.toString();
          } else {
            return integerFormat(d);
          }
        }
        function computeYScale(xScale) {
          const xDiff = xScale[1] - xScale[0];
          return self.meta.height * xDiff / self.meta.width;
        }
        this.options.xAxis = this.options.xAxis || {};
        this.options.xAxis.type = this.options.xAxis.type || "linear";
        this.options.yAxis = this.options.yAxis || {};
        this.options.yAxis.type = this.options.yAxis.type || "linear";
        const xDomain = this.meta.xDomain = function(axis) {
          if (axis.domain) {
            return axis.domain;
          }
          if (axis.type === "linear") {
            const xLimit = 12;
            return [-xLimit / 2, xLimit / 2];
          } else if (axis.type === "log") {
            return [1, 10];
          }
          throw Error("axis type " + axis.type + " unsupported");
        }(this.options.xAxis);
        const yDomain = this.meta.yDomain = function(axis) {
          if (axis.domain) {
            return axis.domain;
          }
          const yLimit = computeYScale(xDomain);
          if (axis.type === "linear") {
            return [-yLimit / 2, yLimit / 2];
          } else if (axis.type === "log") {
            return [1, 10];
          }
          throw Error("axis type " + axis.type + " unsupported");
        }(this.options.yAxis);
        if (!this.meta.xScale) {
          this.meta.xScale = getD3Scale(this.options.xAxis.type)();
        }
        this.meta.xScale.domain(xDomain).range(this.options.xAxis.invert ? [this.meta.width, 0] : [0, this.meta.width]);
        if (!this.meta.yScale) {
          this.meta.yScale = getD3Scale(this.options.yAxis.type)();
        }
        this.meta.yScale.domain(yDomain).range(this.options.yAxis.invert ? [0, this.meta.height] : [this.meta.height, 0]);
        if (!this.meta.xAxis) {
          this.meta.xAxis = (0, d3_axis_1.axisBottom)(this.meta.xScale);
        }
        this.meta.xAxis.tickSize(this.options.grid ? -this.meta.height : 0).tickFormat(formatter);
        if (!this.meta.yAxis) {
          this.meta.yAxis = (0, d3_axis_1.axisLeft)(this.meta.yScale);
        }
        this.meta.yAxis.tickSize(this.options.grid ? -this.meta.width : 0).tickFormat(formatter);
        this.line = (0, d3_shape_1.line)().x(function(d) {
          return self.meta.xScale(d[0]);
        }).y(function(d) {
          return self.meta.yScale(d[1]);
        });
      }
      drawGraphWrapper() {
        const root = this.root = (0, d3_selection_1.select)(this.options.target).selectAll("svg").data([this.options]);
        this.root.enter = root.enter().append("svg").attr("class", "function-plot").attr("font-size", this.getFontSize());
        root.merge(this.root.enter).attr("width", this.meta.width + this.meta.margin.left + this.meta.margin.right).attr("height", this.meta.height + this.meta.margin.top + this.meta.margin.bottom);
        this.buildTitle();
        this.buildLegend();
        this.buildCanvas();
        this.buildClip();
        this.buildAxis();
        this.buildAxisLabel();
        const tip = this.tip = (0, tip_1.default)(Object.assign(this.options.tip || {}, { owner: this }));
        this.canvas.merge(this.canvas.enter).call(tip);
        this.setUpPlugins();
        this.draw();
        this.buildZoomHelper();
      }
      buildTitle() {
        const selection = this.root.merge(this.root.enter).selectAll("text.title").data(function(d) {
          return [d.title].filter(Boolean);
        });
        const selectionEnter = selection.enter().append("text");
        selectionEnter.merge(selection).attr("class", "title").attr("y", this.meta.margin.top / 2).attr("x", this.meta.margin.left + this.meta.width / 2).attr("font-size", 25).attr("text-anchor", "middle").attr("alignment-baseline", "middle").text(this.options.title);
        selection.exit().remove();
      }
      buildLegend() {
        this.root.enter.append("text").attr("class", "top-right-legend").attr("text-anchor", "end");
        this.root.merge(this.root.enter).select(".top-right-legend").attr("y", this.meta.margin.top / 2).attr("x", this.meta.width + this.meta.margin.left);
      }
      buildCanvas() {
        const canvas = this.canvas = this.root.merge(this.root.enter).selectAll(".canvas").data(function(d) {
          return [d];
        });
        this.canvas.enter = canvas.enter().append("g").attr("class", "canvas");
      }
      buildClip() {
        const id = this.id;
        const defs = this.canvas.enter.append("defs");
        defs.append("clipPath").attr("id", "function-plot-clip-" + id).append("rect").attr("class", "clip static-clip");
        this.canvas.merge(this.canvas.enter).selectAll(".clip").attr("width", this.meta.width).attr("height", this.meta.height);
        defs.append("clipPath").append("marker").attr("id", this.markerId).attr("viewBox", "0 -5 10 10").attr("refX", 10).attr("markerWidth", 5).attr("markerHeight", 5).attr("orient", "auto").append("svg:path").attr("d", "M0,-5L10,0L0,5L0,0").attr("stroke-width", "0px").attr("fill-opacity", 1).attr("fill", "#777");
      }
      buildAxis() {
        const canvasEnter = this.canvas.enter;
        canvasEnter.append("g").attr("class", "x axis");
        canvasEnter.append("g").attr("class", "y axis");
        this.canvas.merge(this.canvas.enter).select(".x.axis").attr("transform", "translate(0," + this.meta.height + ")").call(this.meta.xAxis);
        this.canvas.merge(this.canvas.enter).select(".y.axis").call(this.meta.yAxis);
      }
      buildAxisLabel() {
        const canvas = this.canvas;
        const xLabel = canvas.merge(canvas.enter).selectAll("text.x.axis-label").data(function(d) {
          return [d.xAxis.label].filter(Boolean);
        });
        const xLabelEnter = xLabel.enter().append("text").attr("class", "x axis-label").attr("text-anchor", "end");
        xLabel.merge(xLabelEnter).attr("x", this.meta.width).attr("y", this.meta.height - 6).text(function(d) {
          return d;
        });
        xLabel.exit().remove();
        const yLabel = canvas.merge(canvas.enter).selectAll("text.y.axis-label").data(function(d) {
          return [d.yAxis.label].filter(Boolean);
        });
        const yLabelEnter = yLabel.enter().append("text").attr("class", "y axis-label").attr("y", 6).attr("dy", ".75em").attr("text-anchor", "end").attr("transform", "rotate(-90)");
        yLabel.merge(yLabelEnter).text(function(d) {
          return d;
        });
        yLabel.exit().remove();
      }
      /**
       * @private
       *
       * Draws each of the datums stored in data.options, to do a full
       * redraw call `instance.draw()`
       */
      buildContent() {
        const self = this;
        const canvas = this.canvas;
        canvas.merge(canvas.enter).attr("transform", "translate(" + this.meta.margin.left + "," + this.meta.margin.top + ")");
        const content = this.content = canvas.merge(canvas.enter).selectAll(":scope > g.content").data(function(d) {
          return [d];
        });
        const contentEnter = content.enter().append("g").attr("clip-path", "url(#function-plot-clip-" + this.id + ")").attr("class", "content");
        if (this.options.xAxis.type === "linear") {
          const yOrigin = content.merge(contentEnter).selectAll(":scope > path.y.origin").data([
            [
              [0, this.meta.yScale.domain()[0]],
              [0, this.meta.yScale.domain()[1]]
            ]
          ]);
          const yOriginEnter = yOrigin.enter().append("path").attr("class", "y origin").attr("stroke", "black").attr("opacity", 0.2);
          yOrigin.merge(yOriginEnter).attr("d", this.line);
        }
        if (this.options.yAxis.type === "linear") {
          const xOrigin = content.merge(contentEnter).selectAll(":scope > path.x.origin").data([
            [
              [this.meta.xScale.domain()[0], 0],
              [this.meta.xScale.domain()[1], 0]
            ]
          ]);
          const xOriginEnter = xOrigin.enter().append("path").attr("class", "x origin").attr("stroke", "black").attr("opacity", 0.2);
          xOrigin.merge(xOriginEnter).attr("d", this.line);
        }
        content.merge(contentEnter).call((0, annotations_1.default)({ owner: self }));
        const graphs = content.merge(contentEnter).selectAll(":scope > g.graph").data((d) => {
          return d.data.map(datum_defaults_1.default);
        }, (d) => {
          return d.fn || d.r || d.x || d.text;
        });
        graphs.exit().remove();
        const graphsEnter = graphs.enter().append("g").attr("class", "graph");
        graphs.merge(graphsEnter).each(function(d, index) {
          d.index = index;
          const selection = (0, d3_selection_1.select)(this);
          selection.call(globals_1.default.graphTypes[d.graphType](self));
          selection.call((0, helpers_1.default)(self));
        });
      }
      buildZoomHelper() {
        const self = this;
        if (!this.meta.zoomBehavior) {
          this.meta.zoomBehavior = (0, d3_zoom_1.zoom)().on("zoom", function onZoom(ev) {
            self.getEmitInstance().emit("all:zoom", ev);
          });
          self.meta.zoomBehavior.xScale = self.meta.xScale.copy();
          self.meta.zoomBehavior.yScale = self.meta.yScale.copy();
        }
        self.meta.zoomBehavior.xScale.range(self.meta.xScale.range());
        self.meta.zoomBehavior.yScale.range(self.meta.yScale.range());
        this.canvas.enter.append("rect").call(this.meta.zoomBehavior).attr("class", "zoom-and-drag").style("fill", "none").style("pointer-events", "all").on("mouseover", function(event) {
          self.getEmitInstance().emit("all:mouseover", event);
        }).on("mouseout", function(event) {
          self.getEmitInstance().emit("all:mouseout", event);
        }).on("mousemove", function(event) {
          self.getEmitInstance().emit("all:mousemove", event);
        });
        this.draggable = this.canvas.merge(this.canvas.enter).select(".zoom-and-drag").call((selection) => {
          if (selection.node()) {
            selection.node().instance = self;
          }
        }).attr("width", this.meta.width).attr("height", this.meta.height);
      }
      setUpPlugins() {
        const plugins = this.options.plugins || [];
        const self = this;
        plugins.forEach(function(plugin) {
          plugin(self);
        });
      }
      addLink() {
        for (let i = 0; i < arguments.length; i += 1) {
          this.linkedGraphs.push(arguments[i]);
        }
      }
      updateAxes() {
        const instance = this;
        const canvas = instance.canvas.merge(instance.canvas.enter);
        canvas.select(".x.axis").call(instance.meta.xAxis);
        canvas.select(".y.axis").call(instance.meta.yAxis);
        canvas.selectAll(".axis path, .axis line").attr("fill", "none").attr("stroke", "black").attr("shape-rendering", "crispedges").attr("opacity", 0.1);
      }
      syncOptions() {
        this.options.xAxis.domain = this.meta.xScale.domain();
        this.options.yAxis.domain = this.meta.yScale.domain();
      }
      getFontSize() {
        return Math.max(Math.max(this.meta.width, this.meta.height) / 50, 8);
      }
      draw() {
        const instance = this;
        instance.emit("before:draw");
        instance.syncOptions();
        instance.updateAxes();
        instance.buildContent();
        instance.emit("after:draw");
      }
      setUpEventListeners() {
        const self = this;
        const prevInstance = this.getEmitInstance();
        if (prevInstance) {
          prevInstance.removeAllListeners();
        }
        const events = {
          mousemove: function(coordinates) {
            self.tip.move(coordinates);
          },
          mouseover: function() {
            self.tip.show();
          },
          mouseout: function() {
            self.tip.hide();
          },
          zoom: function zoom({ transform }) {
            if (self.options.disableZoom)
              return;
            const xScaleClone = transform.rescaleX(self.meta.zoomBehavior.xScale).interpolate(d3_interpolate_1.interpolateRound);
            const yScaleClone = transform.rescaleY(self.meta.zoomBehavior.yScale).interpolate(d3_interpolate_1.interpolateRound);
            self.meta.xScale.domain(xScaleClone.domain()).range(xScaleClone.range());
            self.meta.yScale.domain(yScaleClone.domain()).range(yScaleClone.range());
          },
          "tip:update": function({ x, y, index }) {
            const meta = self.root.merge(self.root.enter).datum().data[index];
            const title = meta.title || "";
            const format = meta.renderer || function(x2, y2) {
              return x2.toFixed(3) + ", " + y2.toFixed(3);
            };
            const text = [];
            title && text.push(title);
            text.push(format(x, y));
            self.root.select(".top-right-legend").attr("fill", globals_1.default.COLORS[index]).text(text.join(" "));
          }
        };
        const all = {
          mousemove: function(event) {
            const mouse = (0, d3_selection_1.pointer)(event, self.draggable.node());
            const coordinates = {
              x: self.meta.xScale.invert(mouse[0]),
              y: self.meta.yScale.invert(mouse[1])
            };
            self.linkedGraphs.forEach(function(graph) {
              graph.emit("before:mousemove", coordinates);
              graph.emit("mousemove", coordinates);
            });
          },
          zoom: function(event) {
            self.linkedGraphs.forEach(function(graph) {
              graph.draggable.node().__zoom = self.draggable.node().__zoom;
              graph.emit("zoom", event);
              graph.draw();
            });
            self.emit("all:mousemove", event);
          }
        };
        Object.keys(events).forEach(function(e) {
          !all[e] && self.on("all:" + e, function() {
            const args = Array.prototype.slice.call(arguments);
            self.linkedGraphs.forEach(function(graph) {
              const localArgs = args.slice();
              localArgs.unshift(e);
              graph.emit.apply(graph, localArgs);
            });
          });
          self.on(e, events[e]);
        });
        Object.keys(all).forEach(function(e) {
          self.on("all:" + e, all[e]);
        });
      }
    };
    exports.Chart = Chart;
    Chart.cache = {};
  }
});

// node_modules/function-plot/dist/types.js
var require_types = __commonJS({
  "node_modules/function-plot/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/function-plot/dist/index.js
var require_dist = __commonJS({
  "node_modules/function-plot/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GraphTypeScatter = exports.GraphTypePolyline = exports.GraphTypeInterval = exports.EvalInterval = exports.EvalBuiltIn = exports.registerGraphType = exports.Chart = void 0;
    require_polyfills();
    var chart_1 = require_chart();
    Object.defineProperty(exports, "Chart", { enumerable: true, get: function() {
      return chart_1.Chart;
    } });
    var globals_1 = __importStar(require_globals());
    Object.defineProperty(exports, "registerGraphType", { enumerable: true, get: function() {
      return globals_1.registerGraphType;
    } });
    var graph_types_1 = require_graph_types();
    var $eval = __importStar(require_eval3());
    (0, globals_1.registerGraphType)("polyline", graph_types_1.polyline);
    (0, globals_1.registerGraphType)("interval", graph_types_1.interval);
    (0, globals_1.registerGraphType)("scatter", graph_types_1.scatter);
    (0, globals_1.registerGraphType)("text", graph_types_1.text);
    function functionPlot(options) {
      options.data = options.data || [];
      let instance = chart_1.Chart.cache[options.id];
      if (!instance) {
        instance = new chart_1.Chart(options);
      }
      return instance.build();
    }
    exports.default = functionPlot;
    functionPlot.globals = globals_1.default;
    functionPlot.$eval = $eval;
    functionPlot.graphTypes = { interval: graph_types_1.interval, polyline: graph_types_1.polyline, scatter: graph_types_1.scatter };
    __exportStar(require_types(), exports);
    var eval_1 = require_eval3();
    Object.defineProperty(exports, "EvalBuiltIn", { enumerable: true, get: function() {
      return eval_1.builtIn;
    } });
    Object.defineProperty(exports, "EvalInterval", { enumerable: true, get: function() {
      return eval_1.interval;
    } });
    var graph_types_2 = require_graph_types();
    Object.defineProperty(exports, "GraphTypeInterval", { enumerable: true, get: function() {
      return graph_types_2.interval;
    } });
    Object.defineProperty(exports, "GraphTypePolyline", { enumerable: true, get: function() {
      return graph_types_2.polyline;
    } });
    Object.defineProperty(exports, "GraphTypeScatter", { enumerable: true, get: function() {
      return graph_types_2.scatter;
    } });
    __exportStar(require_helpers(), exports);
  }
});
export default require_dist();
//# sourceMappingURL=function-plot.js.map
